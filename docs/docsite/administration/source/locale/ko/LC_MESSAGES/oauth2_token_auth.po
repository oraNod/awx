# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Red Hat Inc.
# This file is distributed under the same license as the Automation Controller Administration Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Automation Controller Administration Guide 4.3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-04 09:32+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/oauth2_token_auth.rst:4
msgid "Token-Based Authentication"
msgstr "토큰 기반 인증"

#: ../../source/oauth2_token_auth.rst:12
msgid "OAuth 2 is used for token-based authentication. You can manage OAuth tokens as well as applications, a server-side representation of API clients used to generate tokens. By including an OAuth token as part of the HTTP authentication header, you can authenticate yourself and adjust the degree of restrictive permissions in addition to the base RBAC permissions. Refer to `RFC 6749`_ for more details of OAuth 2 specification."
msgstr "OAuth 2는 토큰 기반 인증에 사용됩니다. 토큰을 생성하는 데 사용되는 API 클라이언트의 서버 측 표현체인 애플리케이션뿐만 아니라 OAuth 토큰도 관리할 수 있습니다. OAuth 토큰을 HTTP 인증 헤더에 포함하면 사용자는 자신을 인증할 수 있으며 기본 RBAC 권한 외에도 제한적인 권한의 수준을 조정할 수 있습니다. OAuth 2 사양에 대한 자세한 내용은 `RFC 6749`_를 참조하십시오."

#: ../../source/oauth2_token_auth.rst:16
msgid "For details on using the ``manage`` utility to create tokens, refer to the :ref:`ag_token_utility` section."
msgstr "``manage`` 유틸리티를 사용하여 토큰을 생성하는 방법에 대한 자세한 내용은 :ref:`ag_token_utility` 섹션을 참조하십시오."

#: ../../source/oauth2_token_auth.rst:20
msgid "Managing OAuth 2 Applications and Tokens"
msgstr "OAuth 2 애플리케이션 및 토큰 관리"

#: ../../source/oauth2_token_auth.rst:22
msgid "Applications and tokens can be managed as a top-level resource at ``/api/<version>/applications`` and ``/api/<version>/tokens``. These resources can also be accessed respective to the user at ``/api/<version>/users/N/<resource>``. Applications can be created by making a **POST** to either ``api/<version>/applications`` or ``/api/<version>/users/N/applications``."
msgstr "애플리케이션과 토큰은 ``/api/<version>/applications`` 및 ``/api/<version>/tokens``에서 최상위 리소스로 관리할 수 있습니다. ``/api/<version>/users/N/<resource>``에서 사용자를 기준으로 이러한 리소스에 액세스할 수도 있습니다. ``api/<version>/applications`` 또는 ``/api/<version>/users/N/applications``에 **POST**를 수행하면 애플리케이션을 생성할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:24
msgid "Each OAuth 2 application represents a specific API client on the server side. For an API client to use the API via an application token, it must first have an application and issue an access token. Individual applications are accessible via their primary keys: ``/api/<version>/applications/<pk>/``. Here is a typical application:"
msgstr "각 OAuth 2 애플리케이션은 서버 측의 특정 API 클라이언트를 나타냅니다. API 클라이언트가 애플리케이션 토큰을 통해 API를 사용하려면 먼저 애플리케이션이 있어야 하며 액세스 토큰을 발행해야 합니다. 개별 애플리케이션은 기본 키인 ``/api/<version>/applications/<pk>/``를 통해 액세스할 수 있습니다. 다음은 일반적인 애플리케이션의 예제입니다."

#: ../../source/oauth2_token_auth.rst:64
msgid "As shown in the example above, ``name`` is the human-readable identifier of the application. The rest of the fields, like ``client_id`` and ``redirect_uris``, are mainly used for OAuth2 authorization, which is covered later in :ref:`ag_use_oauth_pat`."
msgstr "위 예제에서와 같이 ``name``은 사람이 읽을 수 있는 애플리케이션 식별자입니다. 나머지 필드(예: ``client_id``, ``redirect_uris``)는 나중에 :ref:`ag_use_oauth_pat`에서 설명하는 OAuth2 인증에 주로 사용됩니다."

#: ../../source/oauth2_token_auth.rst:66
msgid "The values for the ``client_id`` and ``client_secret`` fields are generated during creation and are non-editable identifiers of applications, while ``organization`` and ``authorization_grant_type`` are required upon creation and become non-editable."
msgstr "``client_id`` 및 ``client_secret`` 필드의 값은 생성 과정에서 만들어지며 편집할 수 없는 애플리케이션 식별자이지만 ``organization`` 및 ``authorization_grant_type``은 생성 시 필요하며 편집할 수 없게 됩니다."

#: ../../source/oauth2_token_auth.rst:70
msgid "Access Rules for Applications"
msgstr "애플리케이션 액세스 규칙"

#: ../../source/oauth2_token_auth.rst:72
msgid "Access rules for applications are as follows:"
msgstr "애플리케이션 액세스 규칙은 다음과 같습니다."

#: ../../source/oauth2_token_auth.rst:74
msgid "System administrators can view and manipulate all applications in the system"
msgstr "시스템 관리자는 시스템의 모든 애플리케이션을 보고 조작할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:75
msgid "Organization administrators can view and manipulate all applications belonging to Organization members"
msgstr "조직 관리자는 조직 멤버에 속하는 모든 애플리케이션을 보고 조작할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:76
msgid "Other users can only view, update, and delete their own applications, but cannot create any new applications"
msgstr "다른 사용자는 고유한 애플리케이션을 보거나 업데이트 및 삭제할 수만 있고 새 애플리케이션을 생성할 수는 없습니다."

#: ../../source/oauth2_token_auth.rst:78
msgid "Tokens, on the other hand, are resources used to actually authenticate incoming requests and mask the permissions of the underlying user. There are two ways to create a token:"
msgstr "한편, 토큰은 들어오는 요청을 실제로 인증하고 기본 사용자의 권한을 마스킹하는 데 사용되는 리소스입니다. 토큰을 생성하는 방법에는 다음 두 가지가 있습니다."

#: ../../source/oauth2_token_auth.rst:80
msgid "POST to the ``/api/v2/tokens/`` endpoint with ``application`` and ``scope`` fields to point to the related application and specify token scope"
msgstr "``application`` 및 ``scope`` 필드를 사용해 ``/api/v2/tokens/`` 끝점에 POST를 수행하여 관련 애플리케이션을 가리키고 토큰 범위를 지정"

#: ../../source/oauth2_token_auth.rst:81
msgid "POST to the ``/api/v2/applications/<pk>/tokens/`` endpoint with the ``scope`` field (the parent application will be automatically linked)"
msgstr "``scope`` 필드를 사용해 ``/api/v2/applications/<pk>/tokens/`` 끝점에 POST를 수행하여 상위 애플리케이션을 자동으로 연결"

#: ../../source/oauth2_token_auth.rst:83
msgid "Individual tokens are accessible via their primary keys: ``/api/<version>/tokens/<pk>/``. Here is an example of a typical token:"
msgstr "개별 토큰은 기본 키인 ``/api/<version>/tokens/<pk>/``를 통해 액세스할 수 있습니다. 다음은 일반적인 토큰의 예제입니다."

#: ../../source/oauth2_token_auth.rst:121
msgid "For an OAuth 2 token, the only fully editable fields are ``scope`` and ``description``. The ``application`` field is non-editable on update, and all other fields are entirely non-editable, and are auto-populated during creation, as follows:"
msgstr "OAuth 2 토큰의 경우 완전히 편집 가능한 필드는 ``scope``와 ``description``뿐입니다. ``application`` 필드는 업데이트 시 편집할 수 없으며, 다른 모든 필드는 전혀 편집할 수 없고 생성 과정에서 다음과 같이 자동으로 채워집니다."

#: ../../source/oauth2_token_auth.rst:123
msgid "``user`` field corresponds to the user the token is created for, and in this case, is also the user creating the token"
msgstr "``user`` 필드는 토큰이 생성된 사용자이며, 이 경우 토큰을 생성하는 사용자이기도 합니다."

#: ../../source/oauth2_token_auth.rst:124
msgid "``expires`` is generated according to the controller configuration setting ``OAUTH2_PROVIDER``"
msgstr "``expires``는 컨트롤러 구성 설정 ``OAUTH2_PROVIDER``에 따라 생성됩니다."

#: ../../source/oauth2_token_auth.rst:125
msgid "``token`` and ``refresh_token`` are auto-generated to be non-clashing random strings"
msgstr "``token``과 ``refresh_token``은 충돌하지 않는 임의 문자열로 자동 생성됩니다."

#: ../../source/oauth2_token_auth.rst:127
msgid "Both application tokens and personal access tokens are shown at the ``/api/v2/tokens/`` endpoint. The ``application`` field in the personal access tokens is always **null**. This is a good way to differentiate the two types of tokens."
msgstr "애플리케이션 토큰과 개인 액세스 토큰은 둘 다 ``/api/v2/tokens/`` 끝점에 표시됩니다. 개인 액세스 토큰의 ``application`` 필드는 항상 **null**입니다. 이런 특성에 따라 두 유형의 토큰을 쉽게 구별할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:131
msgid "Access rules for tokens"
msgstr "토큰 액세스 규칙"

#: ../../source/oauth2_token_auth.rst:133
msgid "Access rules for tokens are as follows:"
msgstr "토큰 액세스 규칙은 다음과 같습니다."

#: ../../source/oauth2_token_auth.rst:135
msgid "Users can create a token if they are able to view the related application; and are also able to create a personal token for themselves"
msgstr "사용자가 관련 애플리케이션을 볼 수 있는 경우 토큰을 생성할 수 있으며, 개인 토큰을 직접 생성할 수도 있습니다."

#: ../../source/oauth2_token_auth.rst:136
msgid "System administrators are able to view and manipulate every token in the system"
msgstr "시스템 관리자는 시스템의 모든 토큰을 보고 조작할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:137
msgid "Organization administrators are able to view and manipulate all tokens belonging to Organization members"
msgstr "조직 관리자는 조직 멤버에 속하는 모든 토큰을 보고 조작할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:138
msgid "System Auditors can view all tokens and applications"
msgstr "시스템 감사자는 모든 토큰과 애플리케이션을 볼 수 있습니다."

#: ../../source/oauth2_token_auth.rst:139
msgid "Other normal users are only able to view and manipulate their own tokens"
msgstr "다른 일반 사용자는 고유한 토큰만 보고 조작할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:142
msgid "Users can only view the token or refresh the token value at the time of creation only."
msgstr "사용자는 생성 시에만 토큰을 보거나 토큰 값을 새로 고칠 수 있습니다."

#: ../../source/oauth2_token_auth.rst:147
msgid "Using OAuth 2 Token System for Personal Access Tokens (PAT)"
msgstr "PAT(개인 액세스 토큰)에 OAuth 2 토큰 시스템 사용"

#: ../../source/oauth2_token_auth.rst:149
msgid "The easiest and most common way to obtain an OAuth 2 token is to create a personal access token at the ``/api/v2/users/<userid>/personal_tokens/`` endpoint, as shown in this example below:"
msgstr "OAuth 2 토큰을 얻는 가장 쉽고 일반적인 방법은 아래 예제에서와 같이 ``/api/v2/users/<userid>/personal_tokens/`` 끝점에 개인 액세스 토큰을 생성하는 것입니다."

#: ../../source/oauth2_token_auth.rst:155
msgid "You could also pipe the JSON output through ``jq``, if installed."
msgstr "설치된 경우 ``jq``를 통해 JSON 출력을 파이프할 수도 있습니다."

#: ../../source/oauth2_token_auth.rst:158
msgid "Following is an example of using the personal token to access an API endpoint using curl:"
msgstr "다음은 개인 토큰을 사용하여 curl로 API 끝점에 액세스하는 예제입니다."

#: ../../source/oauth2_token_auth.rst:165
msgid "In |at|, the OAuth 2 system is built on top of the `Django Oauth Toolkit`_, which provides dedicated endpoints for authorizing, revoking, and refreshing tokens. These endpoints can be found under the ``/api/v2/users/<USER_ID>/personal_tokens/`` endpoint, which also provides detailed examples on some typical usage of those endpoints. These special OAuth 2 endpoints only support using the ``x-www-form-urlencoded`` **Content-type**, so none of the ``api/o/*`` endpoints accept ``application/json``."
msgstr "|at|에서는 OAuth 2 시스템이 `Django Oauth Toolkit`_을 기반으로 하므로 토큰 권한 부여, 취소, 새로 고침을 위한 전용 끝점을 제공합니다. 이러한 끝점은 ``/api/v2/users/<USER_ID>/personal_tokens/`` 끝점 아래에서 찾을 수 있으며, 해당 끝점의 몇 가지 일반적인 사용 예제도 자세하게 제공됩니다. 이와 같은 특수 OAuth 2 끝점은  ``x-www-form-urlencoded`` **Content-type** 사용만 지원하므로 ``api/o/*`` 끝점은 ``application/json``을 허용하지 않습니다."

#: ../../source/oauth2_token_auth.rst:171
msgid "You can also request tokens using the ``/api/o/token`` endpoint by specifying ``null`` for the application type."
msgstr "애플리케이션 유형에 ``null``을 지정하여 ``/api/o/token`` 끝점으로 토큰을 요청할 수도 있습니다."

#: ../../source/oauth2_token_auth.rst:174
msgid "Alternatively, you can :ref:`add tokens <userguide:ug_tokens_auth_create>` for users through the controller user interface, as well as configure the expiration of an access token and its associated refresh token (if applicable)."
msgstr "또는 컨트롤러 사용자 인터페이스를 통해 사용자를 위한 :ref:`add tokens <userguide:ug_tokens_auth_create>` 작업을 수행할 수 있으며, 해당하는 경우 액세스 토큰 및 관련 새로 고침 토큰의 만료를 구성할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:180
msgid "Token scope mask over RBAC system"
msgstr "RBAC 시스템 위의 토큰 범위 마스크"

#: ../../source/oauth2_token_auth.rst:182
msgid "The scope of an OAuth 2 token is a space-separated string composed of valid scope keywords, 'read' and 'write'. These keywords are configurable and used to specify permission level of the authenticated API client. Read and write scopes provide a mask layer over the Role-Based Access Control (RBAC) permission system of |at|. Specifically, a 'write' scope gives the authenticated user the full permissions the RBAC system provides, while a 'read' scope gives the authenticated user only read permissions the RBAC system provides. Note that 'write' implies 'read' as well."
msgstr "OAuth 2 토큰의 범위는 유효한 범위 키워드인 'read'와 'write'로 구성된 공백 구분 문자열입니다. 이러한 키워드는 구성 가능하며, 인증된 API 클라이언트의 권한 수준을 지정하는 데 사용됩니다. read 및 write 범위는 |at|의 RBAC(역할 기반 액세스 제어) 권한 시스템 위에 마스크 계층을 제공합니다. 구체적으로 'write' 범위는 RBAC 시스템에서 제공하는 전체 권한을 인증된 사용자에게 부여하는 반면, 'read' 범위는 RBAC 시스템에서 제공하는 읽기 권한만 인증된 사용자에게 부여합니다. 즉, 'write'에는 'read'도 포함됩니다."

#: ../../source/oauth2_token_auth.rst:184
msgid "For example, if you have administrative permissions to a job template, you can view, modify, launch, and delete the job template if authenticated via session or basic authentication. In contrast, if you are authenticated using OAuth 2 token, and the related token scope is 'read', you can only view, but not manipulate or launch the job template, despite being an administrator. If the token scope is 'write' or 'read write', you can take full advantage of the job template as its administrator."
msgstr "예를 들어 작업 템플릿에 대한 관리 권한이 있으면, 세션 또는 기본 인증을 통해 인증된 경우 작업 템플릿을 보거나 수정, 시작, 삭제할 수 있습니다. 반대로, OAuth 2 토큰을 사용하여 인증되었으며 관련 토큰 범위가 'read'인 경우 관리자라도 작업 템플릿을 볼 수만 있고 조작하거나 시작할 수는 없습니다. 토큰 범위가 'write' 또는 'read write'인 경우 관리자 권한으로 작업 템플릿을 최대한 활용할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:187
msgid "To acquire and use a token, first create an application token:"
msgstr "토큰을 얻어서 사용하려면 먼저 애플리케이션 토큰을 생성합니다."

#: ../../source/oauth2_token_auth.rst:189
msgid "Make an application with ``authorization_grant_type`` set to ``password``. HTTP POST the following to the ``/api/v2/applications/`` endpoint  (supplying your own organization ID):"
msgstr "``authorization_grant_type``을 ``password``로 설정하여 애플리케이션을 만듭니다. ``/api/v2/applications/`` 끝점에 다음을 HTTP POST합니다. 이때 고유한 조직 ID를 제공합니다."

#: ../../source/oauth2_token_auth.rst:204
msgid "Make a token and POST to the ``/api/v2/tokens/`` endpoint:"
msgstr "토큰을 만들고 ``/api/v2/tokens/`` 끝점에 POST합니다."

#: ../../source/oauth2_token_auth.rst:214
msgid "This returns a <token-value> that you can use to authenticate with for future requests (this will not be shown again)."
msgstr "그러면 향후 요청 시 인증에 사용할 수 있는 <token-value>가 반환됩니다. 이 값은 다시 표시되지 않습니다."

#: ../../source/oauth2_token_auth.rst:216
msgid "Use the token to access a resource. The following uses curl as an example:"
msgstr "토큰을 사용하여 리소스에 액세스합니다. 다음 예제에서는 curl을 사용합니다."

#: ../../source/oauth2_token_auth.rst:223
msgid "The ``-k`` flag may be needed if you have not set up a CA yet and are using SSL."
msgstr "아직 CA를 설정하지 않았으며 SSL을 사용하는 경우 ``-k`` 플래그가 필요할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:226
msgid "To revoke a token, you can make a DELETE on the detail page for that token, using that token's ID. For example:"
msgstr "토큰을 취소하려면 해당 토큰의 세부 정보 페이지에서 토큰 ID를 사용하여 DELETE를 수행할 수 있습니다. 예를 들어 다음과 같습니다."

#: ../../source/oauth2_token_auth.rst:233
msgid "Similarly, using a token:"
msgstr "마찬가지로, 토큰을 사용하는 경우 다음과 같습니다."

#: ../../source/oauth2_token_auth.rst:243
msgid "Application Functions"
msgstr "애플리케이션 기능"

#: ../../source/oauth2_token_auth.rst:245
msgid "This page lists OAuth 2 utility endpoints used for authorization, token refresh, and revoke. The ``/api/o/`` endpoints are not meant to be used in browsers and do not support HTTP GET. The endpoints prescribed here strictly follow RFC specifications for OAuth 2, so use that for detailed reference. The following is an example of the typical usage of these endpoints in the controller, in particular, when creating an application using various grant types:"
msgstr "이 페이지에는 인증, 토큰 새로 고침, 취소에 사용되는 OAuth 2 유틸리티 끝점이 나와 있습니다. ``/api/o/`` 끝점은 브라우저에서 사용할 수 없으며 HTTP GET을 지원하지 않습니다. 여기에 규정된 끝점은 OAuth 2의 RFC 사양을 엄격하게 따르므로 자세한 내용은 이 사양을 참조하십시오. 다음은 특히 다양한 권한 부여 유형을 사용하여 애플리케이션을 생성할 때 컨트롤러에서 이러한 끝점을 사용하는 일반적인 예제입니다."

#: ../../source/oauth2_token_auth.rst:247
msgid "Authorization Code"
msgstr "인증 코드"

#: ../../source/oauth2_token_auth.rst:248
msgid "Password"
msgstr "암호"

#: ../../source/oauth2_token_auth.rst:252
msgid "You can perform any of the application functions described here using the controller user interface. Refer to the :ref:`Applications <userguide:ug_applications_auth>` section of the |atu| for more detail."
msgstr "컨트롤러 사용자 인터페이스를 사용하여 여기서 설명하는 모든 애플리케이션 기능을 수행할 수 있습니다. 자세한 내용은 |atu|의 :ref:`Applications <userguide:ug_applications_auth>` 섹션을 참조하십시오."

#: ../../source/oauth2_token_auth.rst:257
msgid "Application using ``authorization code`` grant type"
msgstr "``authorization code`` 권한 부여 유형을 사용하는 애플리케이션"

#: ../../source/oauth2_token_auth.rst:259
msgid "The application ``authorization code`` grant type should be used when access tokens need to be issued directly to an external application or service."
msgstr "외부 애플리케이션 또는 서비스에 액세스 토큰을 직접 발행해야 하는 경우 애플리케이션 ``authorization code`` 권한 부여 유형을 사용해야 합니다."

#: ../../source/oauth2_token_auth.rst:263
msgid "You can only use the ``authorization code`` type to acquire an access token when using an application. When integrating an external webapp with |at|, that webapp may need to create OAuth2 Tokens on behalf of users in that other webapp. Creating an application in the controller with the ``authorization code`` grant type is the preferred way to do this because:"
msgstr "애플리케이션을 사용할 때 액세스 토큰을 얻으려면 ``authorization code`` 유형만 사용해야 합니다. 외부 웹앱을 |at|와 통합하는 경우 해당 웹앱에서 다른 웹앱의 사용자를 대신하여 OAuth2 토큰을 생성해야 할 수도 있습니다. ``authorization code`` 권한 부여 유형을 사용하여 컨트롤러에서 애플리케이션을 생성하는 것이 좋으며 그 이유는 다음과 같습니다."

#: ../../source/oauth2_token_auth.rst:265
msgid "this allows an external application to obtain a token from the controller for a user, using their credentials."
msgstr "외부 애플리케이션에서 사용자 인증 정보를 통해 컨트롤러에서 사용자 토큰을 얻을 수 있습니다."

#: ../../source/oauth2_token_auth.rst:266
msgid "compartmentalized tokens issued for a particular application allows those tokens to be easily managed (revoke all tokens associated with that application without having to revoke *all* tokens in the system, for example)"
msgstr "특정 애플리케이션에 발행되는 분류된 토큰을 사용하므로 해당 토큰을 쉽게 관리할 수 있습니다. 예를 들어 시스템의 *모든* 토큰을 취소하지 않고도 애플리케이션과 연결된 모든 토큰을 취소할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:268
msgid "To create an application named *AuthCodeApp* with the ``authorization-code`` grant type, perform a POST to the ``/api/v2/applications/`` endpoint:"
msgstr "``authorization-code`` 권한 부여 유형을 사용하여 *AuthCodeApp*이라는 애플리케이션을 생성하려면 ``/api/v2/applications/`` 끝점에 POST를 수행합니다."

#: ../../source/oauth2_token_auth.rst:284
msgid "The workflow that occurs when you issue a **GET** to the ``authorize`` endpoint from the client application with the ``response_type``, ``client_id``, ``redirect_uris``, and ``scope``:"
msgstr "``response_type``, ``client_id``, ``redirect_uris``, ``scope``를 사용하여 클라이언트 애플리케이션에서 ``authorize`` 끝점에 **GET**을 발행할 때 발생하는 워크플로우는 다음과 같습니다."

#: ../../source/oauth2_token_auth.rst:286
msgid "The controller responds with the authorization code and status to the ``redirect_uri`` specified in the application."
msgstr "컨트롤러가 애플리케이션에서 지정된 ``redirect_uri``에 인증 코드와 상태로 응답합니다."

#: ../../source/oauth2_token_auth.rst:287
msgid "The client application then makes a **POST** to the ``api/o/token/`` endpoint on the controller with the ``code``, ``client_id``, ``client_secret``, ``grant_type``, and ``redirect_uri``."
msgstr "그런 다음, 클라이언트 애플리케이션이 ``code``, ``client_id``, ``client_secret``, ``grant_type``, ``redirect_uri``를 사용하여 컨트롤러의 ``api/o/token/`` 끝점에 **POST**를 수행합니다."

#: ../../source/oauth2_token_auth.rst:288
msgid "The controller responds with the ``access_token``, ``token_type``, ``refresh_token``, and ``expires_in``."
msgstr "컨트롤러가 ``access_token``, ``token_type``, ``refresh_token``, ``expires_in``으로 응답합니다."

#: ../../source/oauth2_token_auth.rst:291
msgid "Refer to `Django's Test Your Authorization Server`_ toolkit to test this flow."
msgstr "위의 워크플로우를 테스트하려면 `Django's Test Your Authorization Server`_ 툴킷을 참조하십시오."

#: ../../source/oauth2_token_auth.rst:295
msgid "You may specify the number of seconds an authorization code remains valid in the **System settings** screen:"
msgstr "**시스템 설정** 화면에서 인증 코드가 유효한 시간(초)을 지정할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:300
msgid "Requesting an access token after this duration will fail. The duration defaults to 600 seconds (10 minutes), based on the `RFC6749 <https://tools.ietf.org/html/rfc6749>`_ recommendation."
msgstr "이 기간 후에 액세스 토큰을 요청하면 실패합니다. 기간의 기본값은 `RFC6749 <https://tools.ietf.org/html/rfc6749>`_ 권장 사항에 따라 600초(10분)입니다."

#: ../../source/oauth2_token_auth.rst:302
msgid "The best way to set up app integrations with |at| using the Authorization Code grant type is to whitelist the origins for those cross-site requests. More generally, you need to whitelist the service or application you are integrating with the controller, for which you want to provide access tokens. To do this, have your Administrator add this whitelist to their local controller settings:"
msgstr "인증 코드 권한 부여 유형을 사용하여 |at|와 앱의 통합을 설정하는 가장 좋은 방법은 해당 사이트 간 요청의 출처를 허용 목록에 추가하는 것입니다. 좀 더 일반적으로 살펴보면 액세스 토큰을 제공하려는 컨트롤러와 통합 중인 서비스 또는 애플리케이션을 허용 목록에 추가해야 합니다. 이렇게 하려면 관리자가 이 허용 목록을 로컬 컨트롤러 설정에 추가하도록 합니다."

#: ../../source/oauth2_token_auth.rst:311
msgid "Where ``http://django-oauth-toolkit.herokuapp.com`` and ``http://www.example.com`` are applications needing tokens with which to access the controller."
msgstr "위 예제에서 ``http://django-oauth-toolkit.herokuapp.com``과 ``http://www.example.com``은 컨트롤러에 액세스하는 데 사용할 토큰이 있어야 하는 애플리케이션입니다."

#: ../../source/oauth2_token_auth.rst:314
msgid "Application using ``password`` grant type"
msgstr "``password`` 권한 부여 유형을 사용하는 애플리케이션"

#: ../../source/oauth2_token_auth.rst:316
msgid "The ``password`` grant type or ``Resource owner password-based`` grant type is ideal for users who have native access to the web app and should be used when the client is the Resource owner. The following supposes an application, 'Default Application' with grant type ``password``:"
msgstr "``password`` 권한 부여 유형 또는 ``Resource owner password-based`` 권한 부여 유형은 웹앱에 대한 기본 액세스 권한이 있는 사용자에게 적합하며, 클라이언트가 리소스 소유자일 때 사용해야 합니다. 다음 예제에서는 권한 부여 유형 ``password``를 사용하는 'Default Application' 애플리케이션을 가정합니다."

#: ../../source/oauth2_token_auth.rst:335
msgid "Logging in is not required for ``password`` grant type, so you can simply use curl to acquire a personal access token through the ``/api/v2/tokens/`` endpoint:"
msgstr "``password`` 권한 부여 유형에는 로그인이 필요하지 않으므로 curl을 사용하여 ``/api/v2/tokens/`` 끝점을 통해 개인 액세스 토큰을 얻을 수 있습니다."

#: ../../source/oauth2_token_auth.rst:351
#: ../../source/oauth2_token_auth.rst:411
#: ../../source/oauth2_token_auth.rst:450
msgid "The special OAuth 2 endpoints only support using the ``x-www-form-urlencoded`` **Content-type**, so as a result, none of the ``api/o/*`` endpoints accept ``application/json``."
msgstr "특수 OAuth 2 끝점은 ``x-www-form-urlencoded`` **Content-type** 사용만 지원하므로 ``api/o/*`` 끝점은 ``application/json``을 허용하지 않습니다."

#: ../../source/oauth2_token_auth.rst:353
msgid "Upon success, a response displays in JSON format containing the access token, refresh token and other information:"
msgstr "성공할 경우에는 액세스 토큰, 새로 고침 토큰, 기타 정보를 포함하는 응답이 JSON 포맷으로 표시됩니다."

#: ../../source/oauth2_token_auth.rst:373
msgid "Application Token Functions"
msgstr "애플리케이션 토큰 기능"

#: ../../source/oauth2_token_auth.rst:375
msgid "This section describes the refresh and revoke functions associated with tokens. Everything that follows (Refreshing and revoking tokens at the ``/api/o/`` endpoints) can currently only be done with application tokens."
msgstr "이 섹션에서는 토큰과 연결된 새로 고침 및 취소 기능에 대해 설명합니다. 아래의 모든 작업(``/api/o/`` 끝점에서 토큰 새로 고침 및 취소)은 현재 애플리케이션 토큰을 사용해야만 수행할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:379
msgid "Refresh an existing access token"
msgstr "기존 액세스 토큰 새로 고침"

#: ../../source/oauth2_token_auth.rst:381
msgid "The following example shows an existing access token with a refresh token provided:"
msgstr "다음 예제에서는 새로 고침 토큰이 제공된 기존 액세스 토큰을 보여 줍니다."

#: ../../source/oauth2_token_auth.rst:397
msgid "The ``/api/o/token/`` endpoint is used for refreshing the access token:"
msgstr "``/api/o/token/`` 끝점은 액세스 토큰을 새로 고치는 데 사용됩니다."

#: ../../source/oauth2_token_auth.rst:407
msgid "In the above POST request, ``refresh_token`` is provided by ``refresh_token`` field of the access token above that. The authentication information is of format ``<client_id>:<client_secret>``, where ``client_id`` and ``client_secret`` are the corresponding fields of the underlying related application of the access token."
msgstr "위의 POST 요청에서 ``refresh_token``은 그 위에 있는 액세스 토큰의 ``refresh_token`` 필드에서 제공합니다. 인증 정보는 ``<client_id>:<client_secret>`` 포맷으로 표시됩니다. 여기서 ``client_id``와 ``client_secret``은 액세스 토큰에 있는 관련된 기본 애플리케이션의 해당 필드입니다."

#: ../../source/oauth2_token_auth.rst:413
msgid "Upon success, a response displays in JSON format containing the new (refreshed) access token with the same scope information as the previous one:"
msgstr "성공할 경우에는 범위 정보가 이전 액세스 토큰과 동일한 새로 고친 액세스 토큰을 포함하는 응답이 JSON 포맷으로 표시됩니다."

#: ../../source/oauth2_token_auth.rst:431
msgid "Essentially, the refresh operation replaces the existing token by deleting the original and then immediately creating a new token with the same scope and related application as the original one. Verify that new token is present and the old one is deleted in the ``/api/v2/tokens/`` endpoint."
msgstr "기본적으로 새로 고침 작업은 원래 토큰을 삭제한 다음, 범위와 관련 애플리케이션이 원래 토큰과 동일한 새 토큰을 즉시 생성하여 기존 토큰을 교체합니다. ``/api/v2/tokens/`` 끝점에 새 토큰이 있고 이전 토큰이 삭제되었는지 확인합니다."

#: ../../source/oauth2_token_auth.rst:436
msgid "Revoke an access token"
msgstr "액세스 토큰 취소"

#: ../../source/oauth2_token_auth.rst:438
msgid "Similarly, you can revoke an access token by using the ``/api/o/revoke-token/`` endpoint."
msgstr "마찬가지로, ``/api/o/revoke-token/`` 끝점을 사용하여 액세스 토큰을 취소할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:440
msgid "Revoking an access token by this method is the same as deleting the token resource object, but it allows you to delete a token by providing its token value, and the associated ``client_id`` (and ``client_secret`` if the application is ``confidential``). For example:"
msgstr "이 방법으로 액세스 토큰을 취소하는 경우 토큰 리소스 오브젝트를 삭제하는 것과 동일하지만, 토큰 값과 관련 ``client_id``(및 애플리케이션이 ``confidential``인 경우 ``client_secret``)를 제공하여 토큰을 삭제할 수 있습니다. 예를 들어 다음과 같습니다."

#: ../../source/oauth2_token_auth.rst:455
msgid "The **Allow External Users to Create Oauth2 Tokens** (``ALLOW_OAUTH2_FOR_EXTERNAL_USERS`` in the API) setting is disabled by default. External users refer to users authenticated externally with a service like LDAP, or any of the other SSO services. This setting ensures external users cannot *create* their own tokens. If you enable then disable it, any tokens created by external users in the meantime will still exist, and are not automatically revoked."
msgstr "**외부 사용자가 Oauth2 토큰을 생성할 수 있도록 허용** (API의 ``ALLOW_OAUTH2_FOR_EXTERNAL_USERS``) 설정은 기본적으로 비활성화되어 있습니다. 외부 사용자는 LDAP와 같은 서비스 또는 다른 SSO 서비스를 사용하여 외부에서 인증된 사용자를 가리킵니다. 이 설정은 외부 사용자가 고유한 토큰을 *생성*할 수 없도록 합니다. 설정을 활성화했다가 비활성화하는 경우 외부 사용자가 그동안 생성한 토큰은 모두 유지되며 자동으로 취소되지 않습니다."

#: ../../source/oauth2_token_auth.rst:458
msgid "Alternatively, you can use the ``manage`` utility, :ref:`ag_manage_utility_revoke_tokens`, to revoke tokens as described in the the :ref:`ag_token_utility` section."
msgstr "또는 ``manage`` 유틸리티인 :ref:`ag_manage_utility_revoke_tokens`를 사용하여 :ref:`ag_token_utility` 섹션에 설명된 대로 토큰을 취소할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:461
msgid "This setting can be configured at the system-level in the |at| User Interface:"
msgstr "이 설정은 |at| 사용자 인터페이스를 통해 시스템 수준에서 구성할 수 있습니다."

#: ../../source/oauth2_token_auth.rst:466
msgid "Upon success, a response of ``200 OK`` displays. Verify the deletion by checking whether the token is present in the ``/api/v2/tokens/`` endpoint."
msgstr "성공할 경우에는 ``200 OK`` 응답이 표시됩니다. ``/api/v2/tokens/`` 끝점에 토큰이 있는지 검사하여 삭제 상태를 확인합니다."

