# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Red Hat Inc.
# This file is distributed under the same license as the Ansible Tower
# Administration Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Ansible Tower Administration Guide 3.7.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-07 07:58+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/external_execution_envs.rst:4
msgid "Execution Environments"
msgstr "执行环境"

#: ../../source/external_execution_envs.rst:15
msgid "The controller allows you to execute jobs via ansible playbook runs directly on a member of the cluster or on a pre-provisioned isolated node. In |atversionshortest|, you can execute jobs in a container group only as-needed per playbook. For more information, see :ref:`ag_container_groups` towards the end of this section."
msgstr "通过控制器，您可以使用 ansible playbook 直接在集群成员或预置备的隔离节点上执行作业。在 |atversionshortest| 中，您可以在每个 playbook 中根据需要执行容器组中的作业。如需更多信息，请参阅本节末尾的 :ref:`ag_container_groups` 部分。"

#: ../../source/external_execution_envs.rst:21
msgid "Instance Groups"
msgstr "实例组"

#: ../../source/external_execution_envs.rst:23
msgid "Instances can be grouped into one or more Instance Groups. Instance groups can be assigned to one or more of the resources listed below."
msgstr "实例可以被分为一个或多个不同的实例组。实例组可以分配给下面列出的一个或多个资源。"

#: ../../source/external_execution_envs.rst:25
msgid "Organizations"
msgstr "机构（Organization）"

#: ../../source/external_execution_envs.rst:26
msgid "Inventories"
msgstr "清单（Inventory）"

#: ../../source/external_execution_envs.rst:27
msgid "Job Templates"
msgstr "作业模板（Job Template）"

#: ../../source/external_execution_envs.rst:29
msgid "When a job associated with one of the resources executes, it will be assigned to the instance group associated with the resource. During the execution process, instance groups associated with Job Templates are checked before those associated with Inventories. Similarly, instance groups associated with Inventories are checked before those associated with Organizations. Thus, Instance Group assignments for the three resources form a hierarchy: Job Template **>** Inventory **>** Organization."
msgstr "当与其中一个资源关联的作业执行时，它将被分配给与该资源关联的实例组。在执行过程中，会先检查与作业模板关联的实例组，然后检查与清单关联的实例组。类似地，先检查与清单关联的实例组，然后检查与机构关联的实例组。因此，三种资源的实例组分配形成一个层级结构：作业模板 **>** 清单 **>** 机构。"

#: ../../source/external_execution_envs.rst:31
msgid "Here are some of the things to consider when working with instance groups:"
msgstr "在处理实例组时需要考虑以下几个问题："

#: ../../source/external_execution_envs.rst:33
msgid "You may optionally define other groups and group instances in those groups. These groups should be prefixed with ``instance_group_``. Instances are not required to be in the controller group alongside other ``instance_group_`` groups, but one instance **must** be present in the ``controller`` group. Technically, ``controller`` is a group like any other ``instance_group_`` group, but it must always be present, and if a specific group is not associated with a specific resource, then job execution will always fall back to the ``controller`` group. The ``controller`` instance group always exists (it cannot be deleted nor renamed)."
msgstr "您可以选择在这些组中定义其他的组和组实例。这些组应当带有前缀 ``instance_group_``。实例不需要与其它 ``instance_group_`` 组一起位于控制器组中，但有一个实例**必须**存在于 ``controller`` 组中。从技术方面来说，``controller`` 是像任何其他 ``instance_group_`` 组一样的组，但它必须始终存在，如果某个特定组没有与特定资源关联，则作业执行始终会返回 ``controller`` 组。``controller`` 实例组始终存在（无法删除或重命名）。"

#: ../../source/external_execution_envs.rst:35
msgid "Do not create a group named ``instance_group_controller``."
msgstr "请勿创建名为 ``instance_group_controller`` 的组。"

#: ../../source/external_execution_envs.rst:37
msgid "Do not name any instance the same as a group name."
msgstr "请勿将任何实例命名为与组名相同。"

#: ../../source/external_execution_envs.rst:42
msgid "Configuring Instance Groups from the API"
msgstr "使用 API 配置实例组"

#: ../../source/external_execution_envs.rst:47
msgid "Instance groups can be created by POSTing to ``/api/v2/instance_groups`` as a system administrator."
msgstr "做为一个系统管理员，可以通过向 ``/api/v2/instance_groups`` 发送 POST 来创建示实例组。"

#: ../../source/external_execution_envs.rst:49
msgid "Once created, instances can be associated with an instance group with:"
msgstr "创建后，就可以把实例与实例组进行关联："

#: ../../source/external_execution_envs.rst:55
msgid "An instance that is added to an instance group will automatically reconfigure itself to listen on the group's work queue. See the following section, :ref:`ag_instance_group_policies`, for more details."
msgstr "添加到实例组中的实例将自动重新配置自身，以侦听组的工作队列。如需更多详情，请参阅以下部分 :ref:`ag_instance_group_policies`。"

#: ../../source/external_execution_envs.rst:61
msgid "Instance group policies"
msgstr "实例组策略"

#: ../../source/external_execution_envs.rst:67
msgid "You can configure the controller instances to automatically join Instance Groups when they come online by defining a :term:`policy`. These policies are evaluated for every new instance that comes online."
msgstr "您可以通过定义 :term:`policy`，将控制器实例配置为在其上线时自动加入实例组。这些策略会针对上线的每个新实例进行评估。"

#: ../../source/external_execution_envs.rst:69
msgid "Instance Group Policies are controlled by three optional fields on an ``Instance Group``:"
msgstr "实例组策略由 ``Instance Group`` 的三个可选字段控制："

#: ../../source/external_execution_envs.rst:71
msgid "``policy_instance_percentage``: This is a number between 0 - 100. It guarantees that this percentage of active controller instances will be added to this Instance Group. As new instances come online, if the number of Instances in this group relative to the total number of instances is less than the given percentage, then new ones will be added until the percentage condition is satisfied."
msgstr "``policy_instance_percentage``：一个从 0 到 100 之间的数字。它保证这个百分比的活跃控制器实例会添加到此实例组。随着新实例上线，如果组中实例的数量相对于实例的总数量小于给定的百分比，则将添加新实例，直到满足百分比条件为止。"

#: ../../source/external_execution_envs.rst:72
msgid "``policy_instance_minimum``: This policy attempts to keep at least this many instances in the Instance Group. If the number of available instances is lower than this minimum, then all instances will be placed in this Instance Group."
msgstr "``policy_instance_minimum``：此策略用于将至少这么多的实例保留在实例组中。如果可用实例的数量低于这个最小值，则所有实例都会放置在这个实例组中。"

#: ../../source/external_execution_envs.rst:73
msgid "``policy_instance_list``: This is a fixed list of instance names to always include in this Instance Group."
msgstr "``policy_instance_list``：这是需要始终包括在此实例组中的实例名称列表。"

#: ../../source/external_execution_envs.rst:75
msgid "The Instance Groups list view from the |at| User Interface provides a summary of the capacity levels for each instance group according to instance group policies:"
msgstr "|at| 用户界面中的实例组列表视图根据实例组策略为每个实例组提供容量级别的汇总："

#: ../../source/external_execution_envs.rst:77
msgid "|Instance Group policy example|"
msgstr "|Instance Group policy example|"

#: ../../source/external_execution_envs.rst:79
msgid "Instance Group policy example"
msgstr "实例组策略示例"

#: ../../source/external_execution_envs.rst:83
msgid "Notable policy considerations"
msgstr "重要策略注意事项"

#: ../../source/external_execution_envs.rst:85
msgid "``policy_instance_percentage`` and ``policy_instance_minimum`` both set minimum allocations. The rule that results in more instances assigned to the group will take effect. For example, if you have a ``policy_instance_percentage`` of 50% and a ``policy_instance_minimum`` of 2 and you start 6 instances, 3 of them would be assigned to the Instance Group. If you reduce the number of total instances in the cluster to 2, then both of them would be assigned to the Instance Group to satisfy ``policy_instance_minimum``. This way, you can set a lower bound on the amount of available resources."
msgstr "``policy_instance_percentage`` 和 ``policy_instance_minimum`` 均设置最小分配。其中会为组分配更多实例的设置将生效。例如，``policy_instance_percentage`` 为 50％，``policy_instance_minimum`` 的设置为 2，如果您启动了 6 个实例，则其中 3 个将被分配给实例组。如果将集群中的实例总数减到 2 个，则这两个实例都将分配给实例组（满足 ``policy_instance_minimum`` 的要求）。这样，您可以对可用资源的数量设置下限。"

#: ../../source/external_execution_envs.rst:87
msgid "Policies do not actively prevent instances from being associated with multiple Instance Groups, but this can effectively be achieved by making the percentages add up to 100. If you have 4 instance groups, assign each a percentage value of 25 and the instances will be distributed among them with no overlap."
msgstr "策略不会主动阻止实例与多个实例组关联，但可通过设置百分比使其总和为 100 来实现。例如，有 4 个实例组，为每个实例组分配一个百分比值 25，则实例在实例组中的分布就不会相互重叠。"

#: ../../source/external_execution_envs.rst:91
msgid "Manually pinning instances to specific groups"
msgstr "手动将实例固定到特定的组中"

#: ../../source/external_execution_envs.rst:98
msgid "If you have a special instance which needs to be exclusively assigned to a specific Instance Group but don't want it to automatically join other groups via \"percentage\" or \"minimum\" policies:"
msgstr "如果您有一个特殊的实例，需要把它专门分配给特定的实例组，但不想让它通过“百分比”或“最小”策略自动加入其他组："

#: ../../source/external_execution_envs.rst:100
msgid "Add the instance to one or more Instance Groups' ``policy_instance_list``"
msgstr "将实例添加到一个或多个实例组的 ``policy_instance_list`` 中"

#: ../../source/external_execution_envs.rst:102
msgid "Update the instance's ``managed_by_policy`` property to be ``False``."
msgstr "将实例的 ``managed_by_policy`` 属性更新为 ``False``。"

#: ../../source/external_execution_envs.rst:104
msgid "This will prevent the Instance from being automatically added to other groups based on percentage and minimum policy; it will only belong to the groups you've manually assigned it to:"
msgstr "这可防止实例根据百分比和最低策略被自动添加到其他组中；它只属于您手动将其分配到的组："

#: ../../source/external_execution_envs.rst:120
msgid "Job Runtime Behavior"
msgstr "作业运行时行为"

#: ../../source/external_execution_envs.rst:122
msgid "When you run a job associated with a instance group, some behaviors worth noting are:"
msgstr "当您运行与实例组关联的作业时，需要注意的一些行为有："

#: ../../source/external_execution_envs.rst:124
msgid "If a cluster is divided into separate instance groups, then the behavior is similar to the cluster as a whole. If two instances are assigned to a group then either one is just as likely to receive a job as any other in the same group."
msgstr "如果将集群划分为不同的实例组，则行为与整个集群类似。如果将两个实例分配给一个组，则其中任何一个实例都会像同一组中的另一个实例一样接收作业。"

#: ../../source/external_execution_envs.rst:125
msgid "As controller instances are brought online, it effectively expands the work capacity of the controller system. If those instances are also placed into instance groups, then they also expand that group's capacity. If an instance is performing work and it is a member of multiple groups, then capacity will be reduced from all groups for which it is a member. De-provisioning an instance will remove capacity from the cluster wherever that instance was assigned. See the :ref:`ag_cluster_deprovision` section for more detail."
msgstr "随着更多控制器实例上线，它可以有效地扩展控制器系统的工作容量。如果这些实例也被放入实例组中，则它们也会扩展该组的容量。如果某个实例正在执行工作，且它是多个组的成员，则它的容量就会从它所属的所有组中减少。取消置备实例将从实例分配到的集群中删除容量。如需更多详情，请参阅:ref:`ag_cluster_deprovision`。"

#: ../../source/external_execution_envs.rst:128
msgid "Not all instances are required to be provisioned with an equal capacity."
msgstr "不是所有实例都需要置备相同的容量。"

#: ../../source/external_execution_envs.rst:132
msgid "Control Where a Job Runs"
msgstr "控制作业运行位置"

#: ../../source/external_execution_envs.rst:134
msgid "If any of the job template, inventory, or organization has instance groups associated with them, a job ran from that job template will not be eligible for the default behavior. That means that if all of the instances inside of the instance groups associated with these 3 resources are out of capacity, the job will remain in the pending state until capacity becomes available."
msgstr "如果任何作业模板、清单或机构都有与其关联的实例组，则从该作业模板运行的作业将无法满足默认行为的要求。这意味着，如果与这 3 个资源关联的实例组中的所有实例都容量用尽，则该作业将保持待处理状态，直到有可用容量为止。"

#: ../../source/external_execution_envs.rst:136
msgid "The order of preference in determining which instance group to submit the job to is as follows:"
msgstr "决定哪个实例组提交该作业的优先顺序如下："

#: ../../source/external_execution_envs.rst:138
msgid "job template"
msgstr "作业模板"

#: ../../source/external_execution_envs.rst:139
msgid "inventory"
msgstr "清单"

#: ../../source/external_execution_envs.rst:140
msgid "organization (by way of project)"
msgstr "机构（通过项目）"

#: ../../source/external_execution_envs.rst:142
msgid "If instance groups are associated with the job template, and all of these are at capacity, then the job will be submitted to instance groups specified on inventory, and then organization. Jobs should execute in those groups in preferential order as resources are available."
msgstr "如果实例组与作业模板关联，并且所有这些实例组都满负荷，则该作业将提交到清单上指定的实例组，然后提交到组织。在资源可用时，作业应当在这些组中按优先顺序执行。"

#: ../../source/external_execution_envs.rst:144
msgid "The global ``controller`` group can still be associated with a resource, just like any of the custom instance groups defined in the playbook. This can be used to specify a preferred instance group on the job template or inventory, but still allow the job to be submitted to any instance if those are out of capacity."
msgstr "全局 ``controller`` 组仍然可以与资源关联，就像 playbook 中定义的任何自定义实例组一样。这可用于指定作业模板或清单上的首选实例组，但仍然允许在用尽容量时将作业提交到任何实例。"

#: ../../source/external_execution_envs.rst:146
msgid "As an example, by associating ``group_a`` with a Job Template and also associating the ``controller`` group with its inventory, you allow the ``controller`` group to be used as a fallback in case ``group_a`` gets out of capacity."
msgstr "例如，通过将 ``group_a`` 与作业模板关联并将 ``controller`` 组与其清单关联，您可以在 ``group_a`` 用尽容量时将 ``controller`` 组用作回退 (fallback)。"

#: ../../source/external_execution_envs.rst:148
msgid "In addition, it is possible to not associate an instance group with one resource but designate another resource as the fallback. For example, not associating an instance group with a job template and have it fall back to the inventory and/or the organization's instance group."
msgstr "另外，可以不将实例组与一个资源关联，而是将另一个资源指定为回退。例如，不将实例组与作业模板关联，并把它回退到清单和/或机构的实例组。"

#: ../../source/external_execution_envs.rst:150
msgid "This presents two other great use cases:"
msgstr "这里提供了两个其他的经典用例："

#: ../../source/external_execution_envs.rst:152
msgid "Associating instance groups with an inventory (omitting assigning the job template to an instance group) will allow the user to ensure that any playbook run against a specific inventory will run only on the group associated with it. This can be super useful in the situation where only those instances have a direct link to the managed nodes."
msgstr "将实例组与清单关联（忽略将作业模板分配给实例组）可确保针对一个特定清单运行的 playbook 只在与其关联的组上运行。这对于只有实例组中的实例才可以与受管节点直接连接的情况来说很有用。"

#: ../../source/external_execution_envs.rst:154
msgid "An administrator can assign instance groups to organizations. This effectively allows the administrator to segment out the entire infrastructure and guarantee that each organization has capacity to run jobs without interfering with any other organization's ability to run jobs."
msgstr "管理员可为机构分配实例组。这样，管理员就可以有效地对整个基础架构进行分段，从而确保每个机构都具备运行作业的容量，而不会影响到其它机构运行作业的能力。"

#: ../../source/external_execution_envs.rst:156
msgid "Likewise, an administrator could assign multiple groups to each organization as desired, as in the following scenario:"
msgstr "同样，管理员也可以根据需要为每个机构分配多个组，如以下情境中所示："

#: ../../source/external_execution_envs.rst:158
msgid "There are three instance groups: A, B, and C. There are two organizations: Org1 and Org2."
msgstr "有三个实例组：A、B 和 C。有两个机构：Org1 和 Org2。"

#: ../../source/external_execution_envs.rst:159
msgid "The administrator assigns group A to Org1, group B to Org2 and then assign group C to both Org1 and Org2 as an overflow for any extra capacity that may be needed."
msgstr "管理员将 A 组分配给 Org1，B 组分配给 Org2，然后将 C 组分配给 Org1 和 Org2，作为可能需要的额外容量。"

#: ../../source/external_execution_envs.rst:160
msgid "The organization administrators are then free to assign inventory or job templates to whichever group they want (or just let them inherit the default order from the organization)."
msgstr "然后，机构管理员可以自由地为他们想要的组分配清单或作业模板（或者只是允许它们从机构继承默认顺序）。"

#: ../../source/external_execution_envs.rst:162
msgid "|Instance Group example|"
msgstr "|Instance Group example|"

#: ../../source/external_execution_envs.rst:164
msgid "Instance Group example"
msgstr "实例组示例"

#: ../../source/external_execution_envs.rst:166
msgid "Arranging resources in this way offers a lot of flexibility. Also, you can create instance groups with only one instance, thus allowing you to direct work towards a very specific Host in the controller cluster."
msgstr "以这种方式安排资源非常灵活。另外，您还可以创建只有一个实例的实例组，从而允许您将工作直接指向控制器集群中的特定主机。"

#: ../../source/external_execution_envs.rst:172
msgid "Deprovision Instance Groups"
msgstr "取消置备实例组"

#: ../../source/external_execution_envs.rst:177
msgid "Re-running the setup playbook does not automatically deprovision instances since clusters do not currently distinguish between an instance that was taken offline intentionally or due to failure. Instead, shut down all services on the controller instance and then run the deprovisioning tool from any other instance:"
msgstr "重新运行设置 (setup) playbook 不会自动取消置备实例，因为集群目前不会区分有意关闭的实例与因故障而关闭的实例。而是，关闭控制器实例上的所有服务，然后从任何其他实例运行取消置备工具："

#: ../../source/external_execution_envs.rst:179
msgid "Shut down the instance or stop the service with the command, ``automation-controller-service stop``."
msgstr "使用命令 ``automation-controller-service stop`` 关闭实例或停止服务。"

#: ../../source/external_execution_envs.rst:181
msgid "Run the deprovision command ``$ awx-manage deprovision_instance --hostname=<name used in inventory file>`` from another instance to remove it from the controller cluster registry."
msgstr "从另一个实例运行取消置备命令 ``$ awx-manage deprovision_instance --hostname=<name used in inventory file>``，将其从控制器集群 registry 中删除。"

#: ../../source/external_execution_envs.rst:183
msgid "Example: ``awx-manage deprovision_instance --hostname=hostB``"
msgstr "示例：``awx-manage deprovision_instance --hostname=hostB``"

#: ../../source/external_execution_envs.rst:186
msgid "Similarly, deprovisioning instance groups in the controller does not automatically deprovision or remove instance groups, even though re-provisioning will often cause these to be unused. They may still show up in API endpoints and stats monitoring. These groups can be removed with the following command:"
msgstr "同样，取消置备控制器中的实例组不会自动取消置备或删除实例组，尽管重新置备通常会导致这些实例组没有被使用。它们可能仍然会出现在 API 端点和静态监控中。这些组可以通过以下命令删除："

#: ../../source/external_execution_envs.rst:188
msgid "Example: ``awx-manage unregister_queue --queuename=<name>``"
msgstr "示例：``awx-manage unregister_queue --queuename=<name>``"

#: ../../source/external_execution_envs.rst:190
msgid "Removing an instance's membership from an instance group in the inventory file and re-running the setup playbook does not ensure the instance won't be added back to a group. To be sure that an instance will not be added back to a group, remove via the API and also remove it in your inventory file, or you can stop defining instance groups in the inventory file altogether. You can also manage instance group topology through the |at| User Interface. For more information on managing instance groups in the UI, refer to :ref:`Instance Groups <userguide:ug_instance_groups>` in the |atu|."
msgstr "从清单文件中的实例组删除实例的成员资格不能确保，在重新运行设置 (setup) playbook 时实例不会被添加回组中。要实现这一点，请通过 API 将不需要的实例删除，同时也从清单文件中将其删除。或者，您可以完全停止定义清单文件中的实例组。您还可以通过 |at| 用户界面来管理实例组拓扑。如需有关在 UI 中管理实例组的更多信息，请参阅 |atu| 中的 :ref:`Instance Groups <userguide:ug_instance_groups>`。"

#: ../../source/external_execution_envs.rst:196
msgid "Isolated Instance Groups"
msgstr "隔离实例组"

#: ../../source/external_execution_envs.rst:202
msgid "The controller has the ability to optionally define isolated groups inside security-restricted networking zones from which to run jobs and ad hoc commands. Instances in these groups will not have a full installation of the controller, but will have a minimal set of utilities used to run jobs. Isolated groups must be specified in the inventory file prefixed with ``isolated_group_``. Below is an example of an inventory file for an isolated instance group."
msgstr "控制器能够选择性地定义从中运行作业和临时命令的安全限制联网区内的隔离组。这些组中的实例将无法完全安装控制器，但将使用最小的实用程序集来运行作业。隔离组必须在带有前缀 ``isolated_group_`` 的清单文件中指定。以下是隔离实例组的清单文件示例。"

#: ../../source/external_execution_envs.rst:222
msgid "In the isolated instance group model, \"controller\" instances interact with \"isolated\" instances via a series of Ansible playbooks over SSH. At installation time, by default, a randomized RSA key is generated and distributed as an authorized key to all \"isolated\" instances. The private half of the key is encrypted and stored within the controller database, and is used to authenticate from \"controller\" instances to \"isolated\" instances when jobs are run."
msgstr "在隔离实例组模型中，“controller”实例通过 SSH 以及一系列 Ansible playbook 与“隔离”实例交互。在安装时，默认会生成一个随机的 RSA 密钥，并将它作为授权密钥分发给所有“隔离”实例。密钥的私钥部分进行加密，并存储在控制器数据库中，并在作业运行时用于从“controller”实例到“隔离”实例进行身份验证。"

#: ../../source/external_execution_envs.rst:224
msgid "When a job is scheduled to run on an \"isolated\" instance:"
msgstr "当把一个作业调度为在“隔离”实例上运行时："

#: ../../source/external_execution_envs.rst:226
msgid "The \"controller\" instance compiles metadata required to run the job and copies it to the \"isolated\" instance."
msgstr "“controller”实例编译运行作业所需的元数据并将其复制到“隔离”实例中。"

#: ../../source/external_execution_envs.rst:228
msgid "Once the metadata has been synchronized to the isolated host, the \"controller\" instance starts a process on the \"isolated\" instance, which consumes the metadata and starts running ``ansible/ansible-playbook``. As the playbook runs, job artifacts (such as stdout and job events) are written to disk on the \"isolated\" instance."
msgstr "当元数据与隔离主机同步后，“controller”实例会在“隔离”实例上启动一个进程，该进程消耗了元数据并开始运行 ``ansible/ansible-playbook``。当 playbook 运行时，作业工件（如 stdout 和作业事件）会在“隔离”实例上被写入磁盘。"

#: ../../source/external_execution_envs.rst:230
msgid "While the job runs on the \"isolated\" instance, the \"controller\" instance periodically copies job artifacts (stdout and job events) from the \"isolated\" instance. It consumes these until the job finishes running on the \"isolated\" instance."
msgstr "虽然作业在“隔离”实例上运行，但“controller”实例会定期从“隔离”实例中复制作业工件（stdout 和作业事件）。它会一直消耗元数据，直到作业在“隔离”实例上完成运行。"

#: ../../source/external_execution_envs.rst:234
msgid "Controller nodes fail if they go offline in the middle of an isolated run. If a controller node restarts, or the dispatcher stops during playbook runs, jobs running on that node fails and won't start again when the dispatcher comes online."
msgstr "如果 Controller 节点在隔离运行的中途下线，则会失败。如果控制器节点在 playbook 运行时重启或分发程序停止，则该节点上运行的作业会失败，并在分发程序上线时不会重启。"

#: ../../source/external_execution_envs.rst:237
msgid "Isolated groups (nodes) may be created in a way that allow them to exist inside of a VPC with security rules that only permit the instances in its controller group to access them; only ingress SSH traffic from \"controller\" instances to \"isolated\" instances is required. When provisioning isolated nodes, your install machine needs to be able to have connectivity to the isolated nodes. In cases where an isolated node is not directly accessible but can be reached indirectly through other hosts, you can designate a \"jump host\" by using ProxyCommand in your SSH configuration to specify the jump host and then run the installer."
msgstr "可以创建隔离组（节点），允许它们存在于 VPC 中，其安全规则只允许其控制器组中的实例访问它们；仅需要从“controller”实例到“隔离”实例的入口 SSH 流量。在置备隔离节点时，您的安装机器需要能够连接到隔离节点。如果无法直接访问隔离节点，但可以通过其他主机间接访问，您可以使用 SSH 配置中的 ProxyCommand 指定“跳过主机”，以指定跳过主机，然后运行安装程序。"

#: ../../source/external_execution_envs.rst:239
msgid "|Isolated nodes daisy chain example|"
msgstr "|Isolated nodes daisy chain example|"

#: ../../source/external_execution_envs.rst:241
msgid "Isolated nodes daisy chain example"
msgstr "隔离节点菊花链示例"

#: ../../source/external_execution_envs.rst:243
msgid "|Jump Host example|"
msgstr "|Jump Host example|"

#: ../../source/external_execution_envs.rst:245
msgid "Jump Host example"
msgstr "跳过主机示例"

#: ../../source/external_execution_envs.rst:248
msgid "The recommended system configurations with isolated groups are as follows:"
msgstr "建议系统配置与隔离组如下所示："

#: ../../source/external_execution_envs.rst:250
msgid "Do not create a group named ``isolated_group_controller``."
msgstr "请勿创建名为 ``isolated_group_controller`` 的组。"

#: ../../source/external_execution_envs.rst:251
msgid "Do not put any isolated instances inside the controller group or other ordinary instance groups."
msgstr "请勿将任何隔离实例放到控制器组或者其它普通实例组中。"

#: ../../source/external_execution_envs.rst:252
msgid "Define the controller variable as either a group variable or as a host variable on all the instances in the isolated group. Do not allow isolated instances in the same group to have a different value for this variable - the behavior in this case cannot be predicted."
msgstr "将控制器变量定义为隔离组中所有实例上的组变量或主机变量。请勿允许同一组中的隔离实例具有这个变量的不同值——本例中的行为无法预测。"

#: ../../source/external_execution_envs.rst:253
msgid "Do not put an isolated instance in more than one isolated group."
msgstr "请勿将隔离实例放在多个隔离的组中。"

#: ../../source/external_execution_envs.rst:254
msgid "Do not put an instance in both ordinary groups and isolated groups."
msgstr "请勿将实例放在普通组和隔离组中。"

#: ../../source/external_execution_envs.rst:255
msgid "Isolated instances can be installed on RHEL 7 and later."
msgstr "可在 RHEL 7 及之后的版本上安装隔离实例。"

#: ../../source/external_execution_envs.rst:257
msgid "The following durations associated with isolated groups can be configured in the **Jobs settings** of the Settings menu:"
msgstr "可在 Settings 菜单的 **Jobs settings** 选项卡中配置与隔离组关联的以下持续时间："

#: ../../source/external_execution_envs.rst:259
msgid "**Isolated Status Check Interval**: 30 seconds is the default amount of time set to sleep between status checks for jobs running on isolated instances."
msgstr "**Isolated Status Check Interval**：30 秒是为隔离实例上运行的作业在状态检查之间设置的休眠默认时间。"

#: ../../source/external_execution_envs.rst:260
msgid "**Isolated Launch Timeout**: 600 seconds (10 mins) is the default timeout for launching jobs on isolated instances. This includes the time needed to copy source control files (playbooks) to the isolated instance."
msgstr "**Isolated Launch Timeout**：600 秒（10 分钟）在隔离实例上启动作业的默认超时时间。这包括将源控制文件 (playbook) 复制到隔离实例所需的时间。"

#: ../../source/external_execution_envs.rst:261
msgid "**Isolated Connection Timeout**: 10 seconds is the default Ansible SSH connection timeout when communicating with isolated instances. This value should be substantially greater than the expected network latency."
msgstr "**Isolated Connection Timeout**：10 秒是与隔离实例通信时的默认 Ansible SSH 连接超时。此值应显著大于预期的网络延迟。"

#: ../../source/external_execution_envs.rst:263
msgid "Isolated groups are labeled accordingly in the Instance Groups list view of the controller user interface."
msgstr "在控制器用户界面的 Instance Groups 列表视图中会相应地标记隔离组。"

#: ../../source/external_execution_envs.rst:272
msgid "Container Groups"
msgstr "容器组"

#: ../../source/external_execution_envs.rst:275
msgid "The Container Groups feature is in tech preview and is subject to change in a future release."
msgstr "容器组功能是一个技术预览，可能会在以后的版本中有所变化。"

#: ../../source/external_execution_envs.rst:281
msgid "|at| supports :term:`Container Groups`, which allow you to execute jobs in the controller regardless of whether the controller is installed as a standalone, in  a virtual environment, or in a container. Container groups act as a pool of resources within a virtual environment. You can create instance groups to point to an OpenShift or Kubernetes container, which are job environments that are provisioned on-demand as a Pod that exists only for the duration of the playbook run. This is known as the ephemeral execution model and ensures a clean environment for every job run."
msgstr "|at| 支持 :term:`Container Groups`，它可用于在控制器中执行作业，不管控制器作为单机安装、安装在虚拟环境中或安装在容器中均可。容器组作为虚拟环境中的资源池使用。您可以创建实例组来指向 OpenShift 或 Kubernetes 容器，这是按需置备为 Pod 的作业环境，Pod 仅在 playbook 运行期间存在。这称为瞬时执行模式，可确保每个运行的作业都有一个清洁的环境。"

#: ../../source/external_execution_envs.rst:283
msgid "In some cases, it is desirable to have the execution environment be \"always-on\", which is configured through the creation of an instance."
msgstr "有些情况下，需要将执行环境设置为“始终开启（always-on）”，这通过创建实例来配置。"

#: ../../source/external_execution_envs.rst:286
msgid "Create a container group"
msgstr "创建容器组"

#: ../../source/external_execution_envs.rst:288
msgid "A ``ContainerGroup`` is simply an ``InstanceGroup`` that has an associated Credential that allows for connecting to an OpenShift or Kubernetes cluster. To set up a container group on Kubernetes or OpenShift, you must first have the following:"
msgstr "``ContainerGroup`` 就是一个 ``InstanceGroup``，它具有一个可以连接到 OpenShift 或 Kubernetes 集群的关联凭证。要在 Kubernetes 或 OpenShift 上设置容器组，您必须首先有以下几项："

#: ../../source/external_execution_envs.rst:290
msgid "A namespace you can launch into (there is a \"default\" namespace but most likely varied by customer)"
msgstr "一个可以在其中启动的命名空间（有一个 “default” 命名空间，但多数情况下会因客户而异）"

#: ../../source/external_execution_envs.rst:291
msgid "A service account that has the roles that allow it to launch and manage Pods in this namespace"
msgstr "具有允许在该命名空间中启动和管理 Pod 的角色的服务帐户"

#: ../../source/external_execution_envs.rst:292
msgid "A token associated with that service account (Kubernetes or OpenShift Bearer Token)"
msgstr "与该服务帐户关联的令牌（Kubernetes 或 OpenShift 持有者令牌）"

#: ../../source/external_execution_envs.rst:293
msgid "A CA certificate associated with the cluster"
msgstr "与集群关联的 CA 证书"

#: ../../source/external_execution_envs.rst:295
msgid "To create a container group:"
msgstr "要创建容器组："

#: ../../source/external_execution_envs.rst:297
msgid "Use the controller user interface to create an OpenShift or Kubernetes API bearer token credential that will be used with your container group, see :ref:`ug_credentials_add` in the |atu| for detail."
msgstr "使用控制器用户界面创建与容器组一起使用的 OpenShift 或 Kubernetes API 持有者令牌凭证，详情请参阅 |atu| 中的 :ref:`ug_credentials_add`。"

#: ../../source/external_execution_envs.rst:299
msgid "Create a new container group by navigating to the Instance Groups configuration window by clicking **Instance Groups** from the left navigation bar."
msgstr "从左面的导航栏中点 **Instance Groups** 进入 Instance Groups 配置窗口，创建一个新容器组。"

#: ../../source/external_execution_envs.rst:301
msgid "Click the |add| button and select **Create Container Group**."
msgstr "点击 |add| 按钮并选择 **Create Container Group**。"

#: ../../source/external_execution_envs.rst:303
msgid "add"
msgstr "添加"

#: ../../source/external_execution_envs.rst:305
msgid "|IG - create new CG|"
msgstr "|IG - create new CG|"

#: ../../source/external_execution_envs.rst:307
msgid "IG - create new CG"
msgstr "IG - 新建 CG"

#: ../../source/external_execution_envs.rst:309
msgid "Enter a name for your new container group and select the credential previously created to associate it to the container group."
msgstr "输入新容器组的名称，并选择之前创建的凭证将其与容器组关联。"

#: ../../source/external_execution_envs.rst:313
msgid "Customize the Pod spec"
msgstr "自定义 Pod 规格"

#: ../../source/external_execution_envs.rst:315
msgid "The controller provides a simple default Pod specification, however, you can provide a custom YAML (or JSON) document that overrides the default Pod spec. This field uses any custom fields (i.e., ``image`` or ``namespace``) that can be \"serialized\" as valid Pod JSON or YAML. A full list of options can be found in the `Kubernetes documentation <https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/>`_."
msgstr "控制器提供了一个简单的默认 Pod 规格，但您可以提供一个自定义的 YAML（或 JSON）文档来覆盖默认的 Pod 规格。此字段使用任何可“序列化”为有效 Pod JSON 或 YAML 的自定义字段（例如 ``image`` 或 ``namespace``）。完整选项列表可在 `Kubernetes documentation <https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/>`_ 中找到。"

#: ../../source/external_execution_envs.rst:317
msgid "To customize the Pod spec, specify the namespace in the **Pod Spec Override** field by using the toggle to enable and expand the **Pod Spec Override** field and click **Save** when done."
msgstr "要自定义 Pod 规格，使用切换功能启用并扩展 **Pod Spec Override** 字段，在 **Pod Spec Override** 字段中指定命名空间，完成后点击 **Save**。"

#: ../../source/external_execution_envs.rst:319
msgid "|IG - CG customize pod|"
msgstr "|IG - CG customize pod|"

#: ../../source/external_execution_envs.rst:321
msgid "IG - CG customize pod"
msgstr "IG - CG 自定义 pod"

#: ../../source/external_execution_envs.rst:323
msgid "You may provide additional customizations, if needed. Click **Expand** to view the entire customization window."
msgstr "如果需要，您可以提供额外的定制功能。请点击 **Expand** 查看整个定制窗口。"

#: ../../source/external_execution_envs.rst:329
msgid "The default container group image is pulled from ``registry.redhat.com``. That means that an image pull secret (``imagePullSecrets``) should be specified in the Pod spec. Refer to the *Allowing Pods to Reference Images from Other Secured Registries* section of the `Red Hat Container Registry Authentication article <https://access.redhat.com/RegistryAuthentication>`_ for more information on how to create image pull secrets."
msgstr "默认容器组镜像从 ``registry.redhat.com`` 拉取（pull）。这意味着镜像 pull secret（``imagePullSecrets``）应在 Pod 规格中指定。请参阅 `Red Hat Container Registry Authentication article <https://access.redhat.com/RegistryAuthentication>`_ 的 *Allowing Pods to reference Images from other Secured Registries* 部分，以了解有关如何创建镜像 pull secret 的 更多信息。"

#: ../../source/external_execution_envs.rst:331
msgid "Once the container group is successfully created, the **Details** tab of the newly created container group remains, which allows you to review and edit your container group information. This is the same menu that is opened if the Edit (|edit-button|) button is clicked from the **Instance Group** link. You can also edit **Instances** and review **Jobs** associated with this instance group."
msgstr "成功创建容器组后，新创建的容器组的 **Details** 选项卡将保留，它可用于审核和编辑容器组信息。如果从 **Instance Group** 链接点击 Edit (|edit-button|) 按钮，也打开此菜单。您也可以编辑 **Instances** 并查看与该实例组关联的 **Jobs**。"

#: ../../source/external_execution_envs.rst:333
msgid "edit-button"
msgstr "edit-button"

#: ../../source/external_execution_envs.rst:335
msgid "|IG - example CG successfully created|"
msgstr "|IG - example CG successfully created|"

#: ../../source/external_execution_envs.rst:337
msgid "IG - example CG successfully created"
msgstr "IG - 成功创建 CG 示例"

#: ../../source/external_execution_envs.rst:339
msgid "Container groups and instance groups are labeled accordingly."
msgstr "对容器组和实例组进行相应的标记。"

#: ../../source/external_execution_envs.rst:343
msgid "Despite the fact that customers have custom Pod specs, upgrades may be difficult if the default ``pod_spec`` changes. Most any manifest can be applied to any namespace, with the namespace specified separately, most likely you will only need to override the namespace. Similarly, pinning a default image for different releases of the controller to different versions of the default job runner container is tricky. If the default image is specified in the Pod spec, then upgrades do not pick up the new default changes are made to the default Pod spec."
msgstr "尽管客户有自定义的 Pod 规格，如果默认 ``pod_spec`` 更改，则升级可能会较为困难。大多数清单都可应用于任何命名空间，命名空间单独指定，很可能您只需要覆盖命名空间。类似地，将不同版本控制器的默认镜像固定到默认作业运行程序容器的不同版本较为复杂。如果默认镜像在 Pod 规格中指定，则升级不会选择针对默认 Pod 规格所做的新默认更改。"

#: ../../source/external_execution_envs.rst:347
msgid "Verify container group functions"
msgstr "验证容器组功能"

#: ../../source/external_execution_envs.rst:348
msgid "To verify the deployment and termination of your container:"
msgstr "验证容器的部署和终止："

#: ../../source/external_execution_envs.rst:350
msgid "Create a mock inventory and associate the container group to it by populating the name of the container group in the **Instance Group** field. See :ref:`ug_inventories_add` in the |atu| for detail."
msgstr "通过在 **Instance Group** 字段中填充容器组的名称来创建 mock 清单，并将容器组与其关联。如需详情，请参阅 |atu| 中的 :ref:`ug_inventories_add`。"

#: ../../source/external_execution_envs.rst:352
msgid "|Dummy inventory|"
msgstr "|Dummy inventory|"

#: ../../source/external_execution_envs.rst:354
msgid "Dummy inventory"
msgstr "虚拟清单"

#: ../../source/external_execution_envs.rst:356
msgid "Create \"localhost\" host in inventory with variables:"
msgstr "使用变量在清单中创建“本地主机”主机："

#: ../../source/external_execution_envs.rst:362
msgid "|Inventory with localhost|"
msgstr "|Inventory with localhost|"

#: ../../source/external_execution_envs.rst:364
msgid "Inventory with localhost"
msgstr "带有 localhost 的清单"

#: ../../source/external_execution_envs.rst:366
msgid "Launch an ad hoc job against the localhost using the *ping* or *setup* module. Even though the **Machine Credential** field is required, it does not matter which one is selected for this simple test."
msgstr "使用 *ping* 或者 *setup* 模块对本地主机启动一个临时作业。尽管需要 **Machine Credential**，为此简单测试选择哪个选项无关紧要。"

#: ../../source/external_execution_envs.rst:368
msgid "|Launch inventory with localhost|"
msgstr "|Launch inventory with localhost|"

#: ../../source/external_execution_envs.rst:370
msgid "Launch inventory with localhost"
msgstr "启动带有 localhost 的清单"

#: ../../source/external_execution_envs.rst:372
msgid "You can see in the jobs detail view the container was reached successfully using one of ad hoc jobs."
msgstr "您可在作业详情视图中看到，已成功使用一个临时作业访问了该容器。"

#: ../../source/external_execution_envs.rst:374
msgid "|Inventory with localhost ping success|"
msgstr "|Inventory with localhost ping success|"

#: ../../source/external_execution_envs.rst:376
msgid "Inventory with localhost ping success"
msgstr "带有 localhost 的清单 ping 成功"

#: ../../source/external_execution_envs.rst:379
msgid "If you have an OpenShift or Kubernetes UI, you can see Pods appear and disappear as they deploy and terminate. Alternatively, you can use the CLI to perform a ``get pod`` operation on your namespace to watch these same events occurring in real-time."
msgstr "如果您有 OpenShift 或 Kubernetes UI，您可以看到在部署和终止 Pod 时它会出现和消失。另外，您可以使用 CLI 在命名空间上执行 ``get pod`` 操作，以观察实时发生的这些相同事件。"

#: ../../source/external_execution_envs.rst:383
msgid "View container group jobs"
msgstr "查看容器组作业"

#: ../../source/external_execution_envs.rst:385
msgid "When you run a job associated with a container group, you can see the details of that job in the **Details** view and its associated Instance Group and the execution node that spun up."
msgstr "当您运行与容器组关联的作业时，您可以在 **Details** 视图中看到该作业的详情，以及关联的实例组和执行节点。"

#: ../../source/external_execution_envs.rst:387
msgid "|IG - instances jobs|"
msgstr "|IG - instances jobs|"

#: ../../source/external_execution_envs.rst:389
msgid "IG - instances jobs"
msgstr "IG - 实例作业"

#: ../../source/external_execution_envs.rst:393
msgid "Kubernetes failure conditions"
msgstr "Kubernetes 故障状况"

#: ../../source/external_execution_envs.rst:399
msgid "When running a container group and Kubernetes responds that the resource quota has been exceeded, the controller keeps the job in pending state. Other failures result in the traceback of the **Error Details** field showing the failure reason, similar to the example here:"
msgstr "在运行容器组和 Kubernetes 时，如果出现超出资源配额的问题，则控制器会将作业保持为待处理状态。如果出现其他问题，**Error Details** 字段中的追溯信息会显示故障原因，类似于以下示例："

#: ../../source/external_execution_envs.rst:407
msgid "Container capacity limits"
msgstr "容器容量限制"

#: ../../source/external_execution_envs.rst:412
msgid "Capacity limits and quotas for containers are defined via objects in the Kubernetes API:"
msgstr "容器的容量限制和配额通过 Kubernetes API 中的对象定义："

#: ../../source/external_execution_envs.rst:414
msgid "To set limits on all pods within a given namespace, use the ``LimitRange`` object. Refer to the Kubernetes documentation for `Configure Default Memory Requests and Limits for a Namespace <https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>`_."
msgstr "要设置一个指定命名空间中的所有 pod 的限制，请使用 ``LimitRange`` 对象。请参阅 Kubernetes 文档 `Configure Default Memory Requests and Limits for a Namespace <https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>`_。"

#: ../../source/external_execution_envs.rst:416
msgid "To set limits directly on the pod definition launched by the controller, see `Customize the Pod spec`_ and refer to the Kubernetes documentation to set the options to `Assign Memory Resources to Containers and Pods <https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/>`_."
msgstr "要直接在由控制器启动的 pod 定义上设置限制，请参阅 `Customize the Pod spec`_，并参阅 Kubernetes 文档来设置选项 `Assign Memory Resources to Containers and Pods <https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/>`_。"

#: ../../source/external_execution_envs.rst:420
msgid "Container groups do not use the capacity algorithm that normal nodes use. You would need to explicitly set the number of forks at the job template level, for instance. If forks are configured in the controller, that setting will be passed along to the container."
msgstr "容器组不使用常规节点所使用的容量算法。您需要在作业模板一级为实例明确设置 fork 的数量。如果在控制器中配置了 fork，则该设置会随同传递给容器。"

#~ msgid "You may optionally define other groups and group instances in those groups. These groups should be prefixed with ``instance_group_``. Instances are not required to be in the tower group alongside other ``instance_group_`` groups, but one instance **must** be present in the ``tower`` group. Technically, ``tower`` is a group like any other ``instance_group_`` group, but it must always be present, and if a specific group is not associated with a specific resource, then job execution will always fall back to the ``tower`` group. The ``tower`` instance group always exists (it cannot be deleted nor renamed)."
#~ msgstr "您可以选择在这些组中定义其他的组和组实例。这些组应当带有前缀 ``instance_group_``。实例不需要与其它 ``instance_group_`` 组一起位于 tower 组中，但有一个实例**必须**存在于 ``tower`` 组中。从技术方面来说，``tower`` 是像任何其他 ``instance_group_`` 组一样的组，但它必须始终存在，如果某个特定组没有与特定资源关联，则作业执行始终会返回 ``tower`` 组。``tower`` 实例组始终存在（无法删除或重命名）。"

#~ msgid "Similarly, deprovisioning instance groups in Tower does not automatically deprovision or remove instance groups, even though re-provisioning will often cause these to be unused. They may still show up in API endpoints and stats monitoring. These groups can be removed with the following command:"
#~ msgstr "同样，取消置备 Tower 中的实例组不会自动取消置备或删除实例组，尽管重新置备通常会导致这些实例组没有被使用。它们可能仍然会出现在 API 端点和静态监控中。这些组可以通过以下命令删除："

#~ msgid "|at| supports :term:`Container Groups`, which allow you to execute jobs in Tower regardless of whether Tower is installed as a standalone, in  a virtual environment, or in a container. Container groups act as a pool of resources within a virtual environment. You can create instance groups to point to an OpenShift or Kubernetes container, which are job environments that are provisioned on-demand as a Pod that exists only for the duration of the playbook run. This is known as the ephemeral execution model and ensures a clean environment for every job run."
#~ msgstr "|at| 支持 :term:`Container Groups`，它可用于在 Tower 中执行作业，不管 Tower 作为单机安装、安装在虚拟环境中或安装在容器中均可。容器组作为虚拟环境中的资源池使用。您可以创建实例组来指向 OpenShift 或 Kubernetes 容器，这是按需置备为 Pod 的作业环境，Pod 仅在 playbook 运行期间存在。这称为瞬时执行模式，可确保每个运行的作业都有一个清洁的环境。"

#~ msgid "Tower provides a simple default Pod specification, however, you can provide a custom YAML (or JSON) document that overrides the default Pod spec. This field uses any custom fields (i.e., ``image`` or ``namespace``) that can be \"serialized\" as valid Pod JSON or YAML. A full list of options can be found in the `Kubernetes documentation <https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/>`_."
#~ msgstr "Tower 提供了一个简单的默认 Pod 规格，但您可以提供一个自定义的 YAML（或 JSON）文档来覆盖默认的 Pod 规格。此字段使用任何可“序列化”为有效 Pod JSON 或 YAML 的自定义字段（例如 ``image`` 或 ``namespace``）。完整选项列表可在 `Kubernetes documentation <https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/>`_ 中找到。"

#~ msgid "Despite the fact that customers have custom Pod specs, upgrades may be difficult if the default ``pod_spec`` changes. Most any manifest can be applied to any namespace, with the namespace specified separately, most likely you will only need to override the namespace. Similarly, pinning a default image for different releases of Tower to different versions of the default job runner container is tricky. If the default image is specified in the Pod spec, then upgrades do not pick up the new default changes are made to the default Pod spec."
#~ msgstr "尽管客户有自定义的 Pod 规格，如果默认 ``pod_spec`` 更改，则升级可能会较为困难。大多数清单都可应用于任何命名空间，命名空间单独指定，很可能您只需要覆盖命名空间。类似地，将不同版本 Tower 的默认镜像固定到默认作业运行程序容器的不同版本较为复杂。如果默认镜像在 Pod 规格中指定，则升级不会选择针对默认 Pod 规格所做的新默认更改。"

#~ msgid "When running a container group and Kubernetes responds that the resource quota has been exceeded, Tower keeps the job in pending state. Other failures result in the traceback of the **Error Details** field showing the failure reason, similar to the example here:"
#~ msgstr "在运行容器组和 Kubernetes 时，如果出现超出资源配额的问题，则 Tower 会将作业保持为待处理状态。如果出现其他问题，**Error Details** 字段中的追溯信息会显示故障原因，类似于以下示例："

