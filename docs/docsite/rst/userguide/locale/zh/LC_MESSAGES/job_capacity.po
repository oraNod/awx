# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Red Hat Inc.
# This file is distributed under the same license as the Automation Controller User Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Automation Controller User Guide 4.3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-04 09:32+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/job_capacity.rst:2
msgid "This section describes how to determine capacity for instance groups and its impact to your jobs. For container groups, see :ref:`ag_container_capacity` in the |ata|."
msgstr "本节论述了如何确定实例组的容量及其对您的作业的影响。如需了解容器组，请参阅 |ata| 中的 :ref:`ag_container_capacity`。"

#: ../../source/job_capacity.rst:4
msgid "The |at| capacity system determines how many jobs can run on an instance given the amount of resources available to the instance and the size of the jobs that are running (referred to as *Impact*). The algorithm used to determine this is based entirely on two things:"
msgstr "|at| 容量系统根据实例可使用的资源量以及正在运行的作业的大小（称为*影响*）来确定可在该实例上运行的作业数量。用于确定这一点的算法完全基于两个因素："

#: ../../source/job_capacity.rst:6
msgid "How much memory is available to the system (``mem_capacity``)"
msgstr "系统可使用的内存量 (``mem_capacity``)"

#: ../../source/job_capacity.rst:7
msgid "How much CPU is available to the system (``cpu_capacity``)"
msgstr "系统可使用的 CPU 量 (``cpu_capacity``)"

#: ../../source/job_capacity.rst:9
msgid "Capacity also impacts Instance Groups. Since Groups are made up of instances, likewise, instances can be assigned to multiple groups. This means that impact to one instance can potentially affect the overall capacity of other Groups."
msgstr "容量还会影响实例组。由于组由不同实例组成，同样实例也可以分配到多个组。这意味着对一个实例的影响可能会影响其他组的总容量。"

#: ../../source/job_capacity.rst:11
msgid "Instance Groups (not instances themselves) can be assigned to be used by jobs at various levels (see :ref:`ag_clustering`). When the Task Manager is preparing its graph to determine which group a job will run on, it will commit the capacity of an Instance Group to a job that hasn’t or isn’t ready to start yet."
msgstr "实例组（而非实例本身）可以分配给不同级别的作业使用（请参阅 :ref:`ag_clustering`）。当任务管理器准备其图表来确定作业将在哪个组上运行时，它会将实例组的容量提交到尚未启动或尚未准备好启动的作业。"

#: ../../source/job_capacity.rst:13
msgid "Finally, in smaller configurations, if only one instance is available for a job to run, the Task Manager will allow that job to run on the instance even if it pushes the instance over capacity. This guarantees that jobs themselves won't get stuck as a result of an under-provisioned system."
msgstr "最后，在较小的配置中，如果只有一个实例可用于某个作业运行，则任务管理器将允许该作业在此实例上运行，即使它会使此实例超出容量。这样可保证作业本身不会因为系统配置不足而卡住。"

#: ../../source/job_capacity.rst:15
msgid "Therefore, Capacity and Impact is not a zero-sum system relative to jobs and instances/Instance Groups."
msgstr "因此，容量和影响不是一个相对于作业和实例/实例组的零和系统。"

#: ../../source/job_capacity.rst:17
msgid "For information on sliced jobs and their impact to capacity, see :ref:`ug_job_slice_execution`."
msgstr "有关分片作业及其对容量的影响的信息，请参阅 :ref:`ug_job_slice_execution`。"

#: ../../source/job_capacity.rst:22
msgid "Resource determination for capacity algorithm"
msgstr "容量算法的资源确定"

#: ../../source/job_capacity.rst:24
msgid "The capacity algorithms are defined in order to determine how many forks a system is capable of running simultaneously. This controls how many systems Ansible itself will communicate with simultaneously. Increasing the number of forks a |at| system is running will, in general, allow jobs to run faster by performing more work in parallel. The trade-off is that this will increase the load on the system, which could cause work to slow down overall."
msgstr "定义容量算法是为了确定系统能够同时运行多少个 fork。这决定了 Ansible 本身将同时与多少系统通信。通常，增加 |at| 系统运行的 fork 数量意味着可以并行执行更多工作，从而加快作业运行速度。这么做的代价是，这将增加系统的负载，进而可能导致工作总体上变慢。"

#: ../../source/job_capacity.rst:26
msgid "|At| can operate in two modes when determining capacity. ``mem_capacity`` (the default) will allow you to over-commit CPU resources while protecting the system from running out of memory. If most of your work is not CPU-bound, then selecting this mode will maximize the number of forks."
msgstr "|At| 在确定容量时，可以在两种模式下运行。通过 ``mem_capacity`` （默认），您可以超额提交 CPU 资源，同时防止系统内存不足。如果您的大多数工作不是 CPU 密集型，那么选择此模式可以使 fork 数量最大化。"

#: ../../source/job_capacity.rst:30
msgid "Memory relative capacity"
msgstr "内存相对容量"

#: ../../source/job_capacity.rst:32
msgid "``mem_capacity`` is calculated relative to the amount of memory needed per fork. Taking into account the overhead for internal components, this comes out to be about 100MB per fork. When considering the amount of memory available to Ansible jobs, the capacity algorithm will reserve 2GB of memory to account for the presence of other services. The algorithm formula for this is:"
msgstr "``mem_capacity`` 是相对于每个 fork 所需的内存量来计算的。考虑到内部组件的开销，每个 fork 大约需要 100MB。如果考虑 Ansible 作业可用的内存量，容量算法会保留 2GB 内存，以防存在其他服务。这种情况的算法公式为："

#: ../../source/job_capacity.rst:38
msgid "As an example:"
msgstr "例如："

#: ../../source/job_capacity.rst:44
msgid "Therefore, a system with 4GB of memory would be capable of running 20 forks. The value ``mem_per_fork`` can be controlled by setting the settings value (or environment variable) ``SYSTEM_TASK_FORKS_MEM``, which defaults to 100."
msgstr "具有 4GB 内存的系统可以运行 20 个 fork。``mem_per_fork`` 的值可通过设置设置值（或环境变量）``SYSTEM_TASK_FORKS_MEM`` 来控制，该值默认值为 100。"

#: ../../source/job_capacity.rst:49
msgid "CPU relative capacity"
msgstr "CPU 相对容量"

#: ../../source/job_capacity.rst:51
msgid "Often, Ansible workloads can be fairly CPU-bound. In these cases, sometimes reducing the simultaneous workload allows more tasks to run faster and reduces the average time-to-completion of those jobs."
msgstr "通常，Ansible 工作负载为高度 CPU 密集型。在这些情况下，有时降低并发工作负载可以让更多的任务更快地运行，并减少这些作业的平均完成时间。"

#: ../../source/job_capacity.rst:53
msgid "Just as the ``mem_capacity`` algorithm uses the amount of memory need per fork, the ``cpu_capacity`` algorithm looks at the amount of CPU resources is needed per fork. The baseline value for this is 4 forks per core. The algorithm formula for this is:"
msgstr "就像 ``mem_capacity`` 算法使用每个 fork 所需的内存量一样，``cpu_capacity`` 算法会考虑每个 fork 所需的 CPU 资源量。这种算法的基准值是每个内核的 4 fork。这种情况的算法公式为："

#: ../../source/job_capacity.rst:59
msgid "For example, a 4-core system:"
msgstr "例如，一个 4 核系统："

#: ../../source/job_capacity.rst:65
msgid "The value ``fork_per_cpu`` can be controlled by setting the settings value (or environment variable) ``SYSTEM_TASK_FORKS_CPU`` which defaults to 4."
msgstr "``fork_per_cpu`` 的值可通过设置设置值（或环境变量）``SYSTEM_TASK_FORKS_CPU`` 来控制，它的默认值为 4。"

#: ../../source/job_capacity.rst:69
msgid "Capacity job impacts"
msgstr "容量作业影响"

#: ../../source/job_capacity.rst:71
msgid "When selecting the capacity, it's important to understand how each job type affects capacity."
msgstr "当选择容量时，了解每个作业类型对容量的影响很重要。"

#: ../../source/job_capacity.rst:73
msgid "It's helpful to understand what forks mean to Ansible: https://www.ansible.com/blog/ansible-performance-tuning (see the section on \"Know Your Forks\")."
msgstr "理解 fork 在 Ansible 中的意义会有所帮助：https://www.ansible.com/blog/ansible-performance-tuning（请参阅“了解您的 fork”部分）。"

#: ../../source/job_capacity.rst:75
msgid "The default forks value for Ansible is 5. However, if |at| knows that you're running against fewer systems than that, then the actual concurrency value will be lower."
msgstr "Ansible 的默认 fork 值为 5。但是，如果 |at| 知道您正在针对 5 个以下的系统运行，那么实际的并发值会更低。"

#: ../../source/job_capacity.rst:77
msgid "When a job is run, |at| will add 1 to the number of forks selected to compensate for the Ansible parent process. So if you are running a playbook against 5 systems with a forks value of 5, then the actual forks value from the perspective of Job Impact will be 6."
msgstr "运行作业时，|at| 会在选择的 fork 数量基础上增加 1 以补偿 Ansible 父进程。也就是说，如果您以 5 的 fork 值针对 5 个系统运行 playbook，则从作业影响角度来看，实际的 fork 值为 6。"

#: ../../source/job_capacity.rst:81
msgid "Impact of job types in automation controller"
msgstr "自动化控制器中作业类型的影响"

#: ../../source/job_capacity.rst:83
msgid "Jobs and Ad-hoc jobs follow the above model, forks + 1. If you set a fork value on your job template, your job capacity value will be the minimum of the forks value supplied, and the number of hosts that you have, plus one. The plus one is to account for the parent Ansible process."
msgstr "作业和临时作业遵循上述模型，即 fork + 1。如果在作业模板上设置了 fork 值，则您的作业容量值将是提供的 forks 值的最小值，加上您拥有的主机数量，再加上 1。加上 1 是为了考虑父 Ansible 进程。"

#: ../../source/job_capacity.rst:85
msgid "Instance capacity determines which jobs get assigned to any specific instance. Jobs and ad hoc commands use more capacity if they have a higher forks value."
msgstr "实例容量决定了将哪些作业被分配给任何特定的实例。如果作业和临时命令具有更高的 fork 值，它们将使用更多容量。"

#: ../../source/job_capacity.rst:87
msgid "Other job types have a fixed impact:"
msgstr "其他作业类型具有固定影响："

#: ../../source/job_capacity.rst:89
msgid "Inventory Updates: 1"
msgstr "清单更新：1"

#: ../../source/job_capacity.rst:90
msgid "Project Updates: 1"
msgstr "项目更新：1"

#: ../../source/job_capacity.rst:91
msgid "System Jobs: 5"
msgstr "系统作业：5"

#: ../../source/job_capacity.rst:93
msgid "If you don’t set a forks value on your job template, your job will use Ansible’s default forks value of five. Even though Ansible defaults to five forks, it will use fewer if your job has fewer than five hosts. In general, setting a forks value higher than what the system is capable of could cause trouble by running out of memory or over-committing CPU. So, the job template fork values that you use should fit on the system. If you have playbooks using 1000 forks but none of your systems individually has that much capacity, then your systems are undersized and at risk of performance or resource issues."
msgstr "如果您未在作业模板上设置 fork 值，则您的作业将使用 Ansible 的默认 fork 值 5。如果您的作业只有不到五个主机，即使 Ansible 默认为五个 fork，它也将使用更少数量。通常情况下，设置一个比系统容量高的 fork 值可能导致内存不足或超额提交 CPU，进而造成麻烦。因此，您使用的作业模板 fork 值应与系统相适应。如果您拥有使用 1000 个 fork 的 playbook，但您的任何单独系统都没有如此多容量，那么您的系统容量不足，并存在发生性能或资源问题的风险。"

#: ../../source/job_capacity.rst:97
msgid "Selecting the right capacity"
msgstr "选择正确的容量"

#: ../../source/job_capacity.rst:99
msgid "Selecting a capacity out of the CPU-bound or the memory-bound capacity limits is, in essence, selecting between the minimum or maximum number of forks. In the above examples, the CPU capacity would allow a maximum of 16 forks while the memory capacity would allow 20. For some systems, the disparity between these can be large and often times you may want to have a balance between these two."
msgstr "从 CPU 密集型或内存密集型的容量限制中选择容量实质上就是在最小或最大 fork 数之间进行选择。在上面的示例中，CPU 容量最多允许 16 个 fork，而内存容量最多允许 20 个 fork。对于某些系统，两者之间的差异可能很大，并且通常您可能希望在这两者之间取得平衡。"

#: ../../source/job_capacity.rst:101
msgid "The instance field ``capacity_adjustment`` allows you to select how much of one or the other you want to consider. It is represented as a value between 0.0 and 1.0. If set to a value of 1.0, then the largest value will be used. The above example involves memory capacity, so a value of 20 forks would be selected. If set to a value of 0.0 then the smallest value will be used. A value of 0.5 would be a 50/50 balance between the two algorithms which would be 18:"
msgstr "您可以通过实例字段 ``capacity_adjustment`` 选择要考虑的一种算法或另一算法的容量。它表示为 0.0 到 1.0 之间的值。如果设置为 1.0，则将使用最大值。上面的示例涉及内存容量，因此将选择 20 个 fork 的值。如果设置为 0.0，则将使用最小值。0.5 的值将在两种算法之间达到 50/50 平衡，即 18："

#: ../../source/job_capacity.rst:107
msgid "To view or edit the capacity in the user interface, select the **Instances** tab of the Instance Group."
msgstr "要在用户界面中查看或编辑容量，请选择实例组的 **Instances** 标签页。"

