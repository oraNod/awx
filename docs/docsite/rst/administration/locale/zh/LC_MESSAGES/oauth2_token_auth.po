# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Red Hat Inc.
# This file is distributed under the same license as the Automation Controller Administration Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Automation Controller Administration Guide 4.3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-04 09:32+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/oauth2_token_auth.rst:4
msgid "Token-Based Authentication"
msgstr "基于令牌的验证"

#: ../../source/oauth2_token_auth.rst:12
msgid "OAuth 2 is used for token-based authentication. You can manage OAuth tokens as well as applications, a server-side representation of API clients used to generate tokens. By including an OAuth token as part of the HTTP authentication header, you can authenticate yourself and adjust the degree of restrictive permissions in addition to the base RBAC permissions. Refer to `RFC 6749`_ for more details of OAuth 2 specification."
msgstr "使用 OAuth 2 进行基于令牌的身份验证。您可以管理 OAuth 令牌以及应用，即用于生成令牌的 API 客户端的服务器端系统。通过将 OAuth 令牌作为 HTTP 验证标头的一部分，您可以自行验证身份，并调整除了基本 RBAC 权限外的限制性权限的程度。如需 OAuth 2 规格的详情，请参阅 `RFC 6749`_。"

#: ../../source/oauth2_token_auth.rst:16
msgid "For details on using the ``manage`` utility to create tokens, refer to the :ref:`ag_token_utility` section."
msgstr "如需有关使用 ``manage`` 实用程序创建令牌的详情，请参考 :ref:`ag_token_utility` 部分。"

#: ../../source/oauth2_token_auth.rst:20
msgid "Managing OAuth 2 Applications and Tokens"
msgstr "管理 OAuth 2 应用和令牌"

#: ../../source/oauth2_token_auth.rst:22
msgid "Applications and tokens can be managed as a top-level resource at ``/api/<version>/applications`` and ``/api/<version>/tokens``. These resources can also be accessed respective to the user at ``/api/<version>/users/N/<resource>``. Applications can be created by making a **POST** to either ``api/<version>/applications`` or ``/api/<version>/users/N/applications``."
msgstr "应用和令牌可以作为 ``/api/<version>/applications`` 和 ``/api/<version>/tokens`` 的顶层资源进行管理。这些资源也可以由 ``/api/<version>/users/N/<resource>`` 的用户相应地访问。可以通过对 ``api/<version>/applications`` 或 ``/api/<version>/users/N/applications`` 发出 **POST** 来创建应用。"

#: ../../source/oauth2_token_auth.rst:24
msgid "Each OAuth 2 application represents a specific API client on the server side. For an API client to use the API via an application token, it must first have an application and issue an access token. Individual applications are accessible via their primary keys: ``/api/<version>/applications/<pk>/``. Here is a typical application:"
msgstr "每个 OAuth 2 应用都代表了服务器端的一个特定的 API 客户端。对于 API 客户端，要通过应用令牌使用 API，它必须首先具有一个应用并签发了一个访问令牌。每个应用都可通过主键：``/api/<version>/applications/<pk>/`` 访问。这里是一个典型的应用："

#: ../../source/oauth2_token_auth.rst:64
msgid "As shown in the example above, ``name`` is the human-readable identifier of the application. The rest of the fields, like ``client_id`` and ``redirect_uris``, are mainly used for OAuth2 authorization, which is covered later in :ref:`ag_use_oauth_pat`."
msgstr "如上例所示，``name`` 是应用的人类可读标识符。其它字段（如 ``client_id`` 和 ``redirect_uris``）主要用于 OAuth2 授权，它在后面的:ref:`ag_use_oauth_pat` 中介绍。"

#: ../../source/oauth2_token_auth.rst:66
msgid "The values for the ``client_id`` and ``client_secret`` fields are generated during creation and are non-editable identifiers of applications, while ``organization`` and ``authorization_grant_type`` are required upon creation and become non-editable."
msgstr "``client_id`` 和 ``client_secret`` 字段的值在创建过程中生成 ，它们是应用的不可编辑标识符，而在创建时还需要 ``organization`` 和 ``authorization_grant_type``，并变为不可编辑。"

#: ../../source/oauth2_token_auth.rst:70
msgid "Access Rules for Applications"
msgstr "应用的访问规则"

#: ../../source/oauth2_token_auth.rst:72
msgid "Access rules for applications are as follows:"
msgstr "应用的访问规则如下："

#: ../../source/oauth2_token_auth.rst:74
msgid "System administrators can view and manipulate all applications in the system"
msgstr "系统管理员可以查看并操作系统中的所有应用"

#: ../../source/oauth2_token_auth.rst:75
msgid "Organization administrators can view and manipulate all applications belonging to Organization members"
msgstr "机构管理员可以查看和操作属于机构成员的所有应用"

#: ../../source/oauth2_token_auth.rst:76
msgid "Other users can only view, update, and delete their own applications, but cannot create any new applications"
msgstr "其他用户只能查看、更新和删除自己的应用，但无法创建新应用"

#: ../../source/oauth2_token_auth.rst:78
msgid "Tokens, on the other hand, are resources used to actually authenticate incoming requests and mask the permissions of the underlying user. There are two ways to create a token:"
msgstr "另一方面，令牌是用于实际身份验证传入请求和屏蔽底层用户权限的资源。令牌可以通过两个方法创建："

#: ../../source/oauth2_token_auth.rst:80
msgid "POST to the ``/api/v2/tokens/`` endpoint with ``application`` and ``scope`` fields to point to the related application and specify token scope"
msgstr "使用 ``application`` 和 ``scope`` 字段发布到 ``/api/v2/tokens/`` 端点，以指向相关应用并指定令牌范围"

#: ../../source/oauth2_token_auth.rst:81
msgid "POST to the ``/api/v2/applications/<pk>/tokens/`` endpoint with the ``scope`` field (the parent application will be automatically linked)"
msgstr "使用 ``scope`` 字段发布到 ``/api/v2/applications/<pk>/tokens/`` 端点（父应用会自动链接）"

#: ../../source/oauth2_token_auth.rst:83
msgid "Individual tokens are accessible via their primary keys: ``/api/<version>/tokens/<pk>/``. Here is an example of a typical token:"
msgstr "单独的令牌可以通过它们的主键：``/api/<version>/tokens/<pk>/`` 访问。这里是一个典型令牌的示例："

#: ../../source/oauth2_token_auth.rst:121
msgid "For an OAuth 2 token, the only fully editable fields are ``scope`` and ``description``. The ``application`` field is non-editable on update, and all other fields are entirely non-editable, and are auto-populated during creation, as follows:"
msgstr "对于 OAuth 2 令牌，唯一完全可编辑的字段是 ``scope`` 和 ``description``。``application`` 字段在更新时不可编辑，且所有其他字段完全不可编辑，并在创建过程中自动填充，如下所示："

#: ../../source/oauth2_token_auth.rst:123
msgid "``user`` field corresponds to the user the token is created for, and in this case, is also the user creating the token"
msgstr "``user`` 字段与为其创建令牌的用户对应，在本例中，也是创建令牌的用户"

#: ../../source/oauth2_token_auth.rst:124
msgid "``expires`` is generated according to the controller configuration setting ``OAUTH2_PROVIDER``"
msgstr "``expires`` 根据控制器配置设置生成 ``OAUTH2_PROVIDER``"

#: ../../source/oauth2_token_auth.rst:125
msgid "``token`` and ``refresh_token`` are auto-generated to be non-clashing random strings"
msgstr "``token`` 和 ``refresh_token`` 是自动生成的、没有冲突的随机字符串"

#: ../../source/oauth2_token_auth.rst:127
msgid "Both application tokens and personal access tokens are shown at the ``/api/v2/tokens/`` endpoint. The ``application`` field in the personal access tokens is always **null**. This is a good way to differentiate the two types of tokens."
msgstr "应用令牌和个人访问令牌都显示在 ``/api/v2/tokens/`` 端点中。个人访问令牌中的 ``application`` 字段始终为 **null**。这是区分两种令牌的好方法。"

#: ../../source/oauth2_token_auth.rst:131
msgid "Access rules for tokens"
msgstr "令牌的访问规则"

#: ../../source/oauth2_token_auth.rst:133
msgid "Access rules for tokens are as follows:"
msgstr "令牌的访问规则如下："

#: ../../source/oauth2_token_auth.rst:135
msgid "Users can create a token if they are able to view the related application; and are also able to create a personal token for themselves"
msgstr "如果用户能够查看相关应用，则可以创建令牌；并且用户也可以为自己创建个人令牌。"

#: ../../source/oauth2_token_auth.rst:136
msgid "System administrators are able to view and manipulate every token in the system"
msgstr "系统管理员可以查看并操作系统中的每个令牌"

#: ../../source/oauth2_token_auth.rst:137
msgid "Organization administrators are able to view and manipulate all tokens belonging to Organization members"
msgstr "机构管理员可以查看和操作属于机构成员的所有令牌"

#: ../../source/oauth2_token_auth.rst:138
msgid "System Auditors can view all tokens and applications"
msgstr "系统审核员（Auditor）可查看所有令牌和应用"

#: ../../source/oauth2_token_auth.rst:139
msgid "Other normal users are only able to view and manipulate their own tokens"
msgstr "其他普通用户只能查看和操作自己的令牌"

#: ../../source/oauth2_token_auth.rst:142
msgid "Users can only view the token or refresh the token value at the time of creation only."
msgstr "用户只能在创建时查看令牌或刷新令牌值。"

#: ../../source/oauth2_token_auth.rst:147
msgid "Using OAuth 2 Token System for Personal Access Tokens (PAT)"
msgstr "将 OAuth 2 令牌系统用于个人访问令牌 (PAT)"

#: ../../source/oauth2_token_auth.rst:149
msgid "The easiest and most common way to obtain an OAuth 2 token is to create a personal access token at the ``/api/v2/users/<userid>/personal_tokens/`` endpoint, as shown in this example below:"
msgstr "获取 OAuth 2 令牌的最简单和最常见的方法是在 ``/api/v2/users/<userid>/personal_tokens/`` 端点上创建个人访问令牌，如下例所示："

#: ../../source/oauth2_token_auth.rst:155
msgid "You could also pipe the JSON output through ``jq``, if installed."
msgstr "如果已安装，您还可以通过 ``jq`` 对 JSON 输出进行 pipe 操作。"

#: ../../source/oauth2_token_auth.rst:158
msgid "Following is an example of using the personal token to access an API endpoint using curl:"
msgstr "以下是使用个人令牌访问使用 curl 的 API 端点的示例："

#: ../../source/oauth2_token_auth.rst:165
msgid "In |at|, the OAuth 2 system is built on top of the `Django Oauth Toolkit`_, which provides dedicated endpoints for authorizing, revoking, and refreshing tokens. These endpoints can be found under the ``/api/v2/users/<USER_ID>/personal_tokens/`` endpoint, which also provides detailed examples on some typical usage of those endpoints. These special OAuth 2 endpoints only support using the ``x-www-form-urlencoded`` **Content-type**, so none of the ``api/o/*`` endpoints accept ``application/json``."
msgstr "在 |at| 中，OAuth 2 系统构建在 `Django Oauth Toolkit`_ 上，为授权、撤销和刷新令牌提供专用端点。这些端点可以在 ``/api/v2/users/<USER_ID>/personal_tokens/`` 端点下找到，它还提供了这些端点的一些用法的详细示例。这些特殊 OAuth 2 端点仅支持使用 ``x-www-form-urlencoded`` **Content-type**，因此没有 ``api/o/*`` 端点接受 ``application/json`` 。"

#: ../../source/oauth2_token_auth.rst:171
msgid "You can also request tokens using the ``/api/o/token`` endpoint by specifying ``null`` for the application type."
msgstr "您还可以通过为应用程序类型指定 ``null`` ，使用 ``/api/o/token`` 端点来请求令牌。"

#: ../../source/oauth2_token_auth.rst:174
msgid "Alternatively, you can :ref:`add tokens <userguide:ug_tokens_auth_create>` for users through the controller user interface, as well as configure the expiration of an access token and its associated refresh token (if applicable)."
msgstr "或者，您可以通过控制器用户界面为用户 :ref:`add tokens <userguide:ug_tokens_auth_create>`，并配置访问令牌的过期时间及其关联的刷新令牌（如果适用）。"

#: ../../source/oauth2_token_auth.rst:180
msgid "Token scope mask over RBAC system"
msgstr "RBAC 系统的令牌范围掩码"

#: ../../source/oauth2_token_auth.rst:182
msgid "The scope of an OAuth 2 token is a space-separated string composed of valid scope keywords, 'read' and 'write'. These keywords are configurable and used to specify permission level of the authenticated API client. Read and write scopes provide a mask layer over the Role-Based Access Control (RBAC) permission system of |at|. Specifically, a 'write' scope gives the authenticated user the full permissions the RBAC system provides, while a 'read' scope gives the authenticated user only read permissions the RBAC system provides. Note that 'write' implies 'read' as well."
msgstr "OAuth 2 令牌的范围是一个由空格分隔的、包括有效范围关键字（’read’ 和 ’write’）的字符串。这些关键字可以被配置，用来指定经过身份验证的 API 客户端的权限级别。通过使用 read 和 write 范围，可以在 |at| 的基于角色的访问控制 (RBAC) 权限系统上提供一个掩码层。”write” 范围为经过身份验证的用户提供了 RBAC 系统的完整权限，而“read”范围则仅为经过身份验证的用户提供读取权限。请注意，“write”包括了“read”的权限。"

#: ../../source/oauth2_token_auth.rst:184
msgid "For example, if you have administrative permissions to a job template, you can view, modify, launch, and delete the job template if authenticated via session or basic authentication. In contrast, if you are authenticated using OAuth 2 token, and the related token scope is 'read', you can only view, but not manipulate or launch the job template, despite being an administrator. If the token scope is 'write' or 'read write', you can take full advantage of the job template as its administrator."
msgstr "例如，如果您对作业模板有管理权限，则当通过会话或基本身份验证进行了身份验证后，可以查看、修改、启动和删除作业模板。相反，如果您使用 OAuth 2 令牌进行身份验证，而相关的令牌范围为“read”，您只能查看，但不能操作或启动作业模板，即使管理员也是如此。如果令牌范围是“write”或“read write”，则可以作为管理员充分利用作业模板。"

#: ../../source/oauth2_token_auth.rst:187
msgid "To acquire and use a token, first create an application token:"
msgstr "要获取和使用令牌，首先请创建一个应用令牌："

#: ../../source/oauth2_token_auth.rst:189
msgid "Make an application with ``authorization_grant_type`` set to ``password``. HTTP POST the following to the ``/api/v2/applications/`` endpoint  (supplying your own organization ID):"
msgstr "创建一个应用，``authorization_grant_type`` 设置为 ``password``。HTTP 将以下内容 POST 到 ``/api/v2/applications/`` 端点（提供您自己的机构 ID）："

#: ../../source/oauth2_token_auth.rst:204
msgid "Make a token and POST to the ``/api/v2/tokens/`` endpoint:"
msgstr "创建一个端点并 POST 到 ``/api/v2/tokens/``："

#: ../../source/oauth2_token_auth.rst:214
msgid "This returns a <token-value> that you can use to authenticate with for future requests (this will not be shown again)."
msgstr "这会返回 <token-value>，可以用来为将来的请求进行身份验证（这不会再次显示）。"

#: ../../source/oauth2_token_auth.rst:216
msgid "Use the token to access a resource. The following uses curl as an example:"
msgstr "使用令牌访问资源。以下使用 curl 作为示例："

#: ../../source/oauth2_token_auth.rst:223
msgid "The ``-k`` flag may be needed if you have not set up a CA yet and are using SSL."
msgstr "如果您还没有设置 CA 且正在使用 SSL，则可能需要 ``-k`` 标志。"

#: ../../source/oauth2_token_auth.rst:226
msgid "To revoke a token, you can make a DELETE on the detail page for that token, using that token's ID. For example:"
msgstr "要撤销令牌，您可以使用该令牌的 ID 在该令牌的详情页面上进行 DELETE。例如："

#: ../../source/oauth2_token_auth.rst:233
msgid "Similarly, using a token:"
msgstr "同样，使用令牌："

#: ../../source/oauth2_token_auth.rst:243
msgid "Application Functions"
msgstr "应用功能"

#: ../../source/oauth2_token_auth.rst:245
msgid "This page lists OAuth 2 utility endpoints used for authorization, token refresh, and revoke. The ``/api/o/`` endpoints are not meant to be used in browsers and do not support HTTP GET. The endpoints prescribed here strictly follow RFC specifications for OAuth 2, so use that for detailed reference. The following is an example of the typical usage of these endpoints in the controller, in particular, when creating an application using various grant types:"
msgstr "本页列出了用于授权、令牌刷新和撤销的 OAuth 2 实用程序端点。``/api/o/`` 端点不会在浏览器中使用，且不支持 HTTP GET。这里介绍的端点严格遵循 OAuth 2 的 RFC 规格，因此使用它进行详细参考。以下示例是控制器中这些端点的典型用法，特别是在使用各种授权类型创建应用时："

#: ../../source/oauth2_token_auth.rst:247
msgid "Authorization Code"
msgstr "授权代码"

#: ../../source/oauth2_token_auth.rst:248
msgid "Password"
msgstr "Password"

#: ../../source/oauth2_token_auth.rst:252
msgid "You can perform any of the application functions described here using the controller user interface. Refer to the :ref:`Applications <userguide:ug_applications_auth>` section of the |atu| for more detail."
msgstr "您可以使用控制器用户界面执行此处所述的全部应用功能。如需更多详情，请参阅 |atu| 的 :ref:`Applications <userguide:ug_applications_auth>` 部分。"

#: ../../source/oauth2_token_auth.rst:257
msgid "Application using ``authorization code`` grant type"
msgstr "使用 ``authorization code`` 授权类型的应用"

#: ../../source/oauth2_token_auth.rst:259
msgid "The application ``authorization code`` grant type should be used when access tokens need to be issued directly to an external application or service."
msgstr "当访问令牌需要签发到一个外部应用程序或服务时，应使用 ``authorization code`` 授权类型。"

#: ../../source/oauth2_token_auth.rst:263
msgid "You can only use the ``authorization code`` type to acquire an access token when using an application. When integrating an external webapp with |at|, that webapp may need to create OAuth2 Tokens on behalf of users in that other webapp. Creating an application in the controller with the ``authorization code`` grant type is the preferred way to do this because:"
msgstr "当使用一个应用程序时，只能使用 ``authorization code`` 类型来获取访问令牌。如果一个外部 web 应用程序与 |at| 集成，那个 web 应用程序可能需要为该应用程序上的用户创建 OAuth2 令牌。实现这个目的的首选做法是在控制器中创建 ``authorization code`` 授权类型的应用程序。这是因为："

#: ../../source/oauth2_token_auth.rst:265
msgid "this allows an external application to obtain a token from the controller for a user, using their credentials."
msgstr "这允许外部应用程序使用用户凭证从控制器获取令牌。"

#: ../../source/oauth2_token_auth.rst:266
msgid "compartmentalized tokens issued for a particular application allows those tokens to be easily managed (revoke all tokens associated with that application without having to revoke *all* tokens in the system, for example)"
msgstr "对为特定应用程序发布的令牌进行分离，可轻松管理这些令牌（例如，在不需要删除系统中*所有*令牌的情况下，删除与该应用程序关联的所有令牌）"

#: ../../source/oauth2_token_auth.rst:268
msgid "To create an application named *AuthCodeApp* with the ``authorization-code`` grant type, perform a POST to the ``/api/v2/applications/`` endpoint:"
msgstr "要使用 ``authorization-code`` 授权类型创建名为 *AuthCodeApp* 的应用程序，请对 ``/api/v2/applications/`` 端点执行 POST:"

#: ../../source/oauth2_token_auth.rst:284
msgid "The workflow that occurs when you issue a **GET** to the ``authorize`` endpoint from the client application with the ``response_type``, ``client_id``, ``redirect_uris``, and ``scope``:"
msgstr "当使用 ``response_type``、``client_id``、``redirect_uris`` 和 ``scope`` 从客户端应用签发 **GET** 到 ``authorize`` 端点时发生的工作流："

#: ../../source/oauth2_token_auth.rst:286
msgid "The controller responds with the authorization code and status to the ``redirect_uri`` specified in the application."
msgstr "控制器使用授权代码和状态响应应用中指定的 ``redirect_uri``。"

#: ../../source/oauth2_token_auth.rst:287
msgid "The client application then makes a **POST** to the ``api/o/token/`` endpoint on the controller with the ``code``, ``client_id``, ``client_secret``, ``grant_type``, and ``redirect_uri``."
msgstr "然后，客户端应用程序使用 ``code``、``client_id``、``client_secret``、``grant_type`` 和 ``redirect_uri`` 向控制器上的 ``api/o/token/`` 端点发出 **POST**。"

#: ../../source/oauth2_token_auth.rst:288
msgid "The controller responds with the ``access_token``, ``token_type``, ``refresh_token``, and ``expires_in``."
msgstr "控制器使用 ``access_token``、``token_type``、``refresh_token`` 和 ``expires_in`` 响应。"

#: ../../source/oauth2_token_auth.rst:291
msgid "Refer to `Django's Test Your Authorization Server`_ toolkit to test this flow."
msgstr "请参阅 `Django's Test Your Authorization Server`_ 工具包来测试这个流。"

#: ../../source/oauth2_token_auth.rst:295
msgid "You may specify the number of seconds an authorization code remains valid in the **System settings** screen:"
msgstr "您可以在 **System settings** 屏幕中指定授权代码保持有效的秒数："

#: ../../source/oauth2_token_auth.rst:300
msgid "Requesting an access token after this duration will fail. The duration defaults to 600 seconds (10 minutes), based on the `RFC6749 <https://tools.ietf.org/html/rfc6749>`_ recommendation."
msgstr "此持续时间后请求访问令牌将会失败。根据 `RFC6749 <https://tools.ietf.org/html/rfc6749>`_ 的建议，持续时间默认为 600 秒（10 分钟）。"

#: ../../source/oauth2_token_auth.rst:302
msgid "The best way to set up app integrations with |at| using the Authorization Code grant type is to whitelist the origins for those cross-site requests. More generally, you need to whitelist the service or application you are integrating with the controller, for which you want to provide access tokens. To do this, have your Administrator add this whitelist to their local controller settings:"
msgstr "使用授权代码授权类型设置应用与 |at| 集成的最佳方法是：将这些跨站点请求的起源列入白名单。更笼统地说，您需要将您要与控制器集成的服务或应用列入白名单，以便为其提供访问令牌。为此，您的管理员将这份白名单添加到其本地控制器设置中："

#: ../../source/oauth2_token_auth.rst:311
msgid "Where ``http://django-oauth-toolkit.herokuapp.com`` and ``http://www.example.com`` are applications needing tokens with which to access the controller."
msgstr "其中 ``http://django-oauth-toolkit.herokuapp.com`` 和 ``http://www.example.com`` 是需要令牌才能访问控制器的应用。"

#: ../../source/oauth2_token_auth.rst:314
msgid "Application using ``password`` grant type"
msgstr "使用 ``password`` 授权类型的应用"

#: ../../source/oauth2_token_auth.rst:316
msgid "The ``password`` grant type or ``Resource owner password-based`` grant type is ideal for users who have native access to the web app and should be used when the client is the Resource owner. The following supposes an application, 'Default Application' with grant type ``password``:"
msgstr "``password`` 或 ``Resource owner password-based`` 授权类型非常适合拥有对 web 应用的原生访问权限并在客户端为资源拥有者时使用的用户。以下是带有授权类型 ``password`` 的 'Default Application'："

#: ../../source/oauth2_token_auth.rst:335
msgid "Logging in is not required for ``password`` grant type, so you can simply use curl to acquire a personal access token through the ``/api/v2/tokens/`` endpoint:"
msgstr "``password`` 授权类型不需要登录，因此您可以简单地使用 curl 通过 ``/api/v2/tokens/`` 端点获取个人访问令牌："

#: ../../source/oauth2_token_auth.rst:351
#: ../../source/oauth2_token_auth.rst:411
#: ../../source/oauth2_token_auth.rst:450
msgid "The special OAuth 2 endpoints only support using the ``x-www-form-urlencoded`` **Content-type**, so as a result, none of the ``api/o/*`` endpoints accept ``application/json``."
msgstr "特殊 OAuth 2 端点只支持使用 ``x-www-form-urlencoded`` **Content-type**，因此，没有 ``api/o/*`` 端点接受 ``application/json``。"

#: ../../source/oauth2_token_auth.rst:353
msgid "Upon success, a response displays in JSON format containing the access token, refresh token and other information:"
msgstr "成功后，会以 JSON 格式显示一个响应，其中包含访问令牌、刷新令牌和其他信息："

#: ../../source/oauth2_token_auth.rst:373
msgid "Application Token Functions"
msgstr "应用令牌功能"

#: ../../source/oauth2_token_auth.rst:375
msgid "This section describes the refresh and revoke functions associated with tokens. Everything that follows (Refreshing and revoking tokens at the ``/api/o/`` endpoints) can currently only be done with application tokens."
msgstr "本节介绍了与令牌关联的刷新和撤销功能。所有随后的功能（刷新和撤销 ``/api/o/`` 端点中的令牌）目前只能使用应用令牌完成。"

#: ../../source/oauth2_token_auth.rst:379
msgid "Refresh an existing access token"
msgstr "刷新现有访问令牌"

#: ../../source/oauth2_token_auth.rst:381
msgid "The following example shows an existing access token with a refresh token provided:"
msgstr "以下示例显示了提供有刷新令牌的现有访问令牌："

#: ../../source/oauth2_token_auth.rst:397
msgid "The ``/api/o/token/`` endpoint is used for refreshing the access token:"
msgstr "``/api/o/token/`` 端点用于刷新访问令牌："

#: ../../source/oauth2_token_auth.rst:407
msgid "In the above POST request, ``refresh_token`` is provided by ``refresh_token`` field of the access token above that. The authentication information is of format ``<client_id>:<client_secret>``, where ``client_id`` and ``client_secret`` are the corresponding fields of the underlying related application of the access token."
msgstr "在上述 POST 请求中，``refresh_token`` 由上方的访问令牌的 ``refresh_token`` 字段提供。身份验证信息的格式是 ``<client_id>:<client_secret>``，其中 ``client_id`` 和 ``client_secret`` 是与访问令牌的底层相关应用的对应字段。"

#: ../../source/oauth2_token_auth.rst:413
msgid "Upon success, a response displays in JSON format containing the new (refreshed) access token with the same scope information as the previous one:"
msgstr "成功后，会以 JSON 格式显示一个响应，其中包含新的（刷新的）访问令牌，其范围信息与前面的信息相同："

#: ../../source/oauth2_token_auth.rst:431
msgid "Essentially, the refresh operation replaces the existing token by deleting the original and then immediately creating a new token with the same scope and related application as the original one. Verify that new token is present and the old one is deleted in the ``/api/v2/tokens/`` endpoint."
msgstr "本质上，刷新操作通过删除原始令牌替换现有的令牌，然后立即创建一个新的令牌，其范围和相关应用与原始令牌相同。验证是否存在新令牌，并在 ``/api/v2/tokens/`` 端点中删除旧令牌。"

#: ../../source/oauth2_token_auth.rst:436
msgid "Revoke an access token"
msgstr "撤销访问令牌"

#: ../../source/oauth2_token_auth.rst:438
msgid "Similarly, you can revoke an access token by using the ``/api/o/revoke-token/`` endpoint."
msgstr "同样，您可以使用 ``/api/o/revoke-token/`` 端点来撤销访问令牌。"

#: ../../source/oauth2_token_auth.rst:440
msgid "Revoking an access token by this method is the same as deleting the token resource object, but it allows you to delete a token by providing its token value, and the associated ``client_id`` (and ``client_secret`` if the application is ``confidential``). For example:"
msgstr "通过此方法撤销访问令牌与删除令牌资源对象相同，但它允许您通过提供令牌值以及关联的 ``client_id``（如果应用程序是 ``confidential``，则为 ``client_secret``）来删除令牌。例如："

#: ../../source/oauth2_token_auth.rst:455
msgid "The **Allow External Users to Create Oauth2 Tokens** (``ALLOW_OAUTH2_FOR_EXTERNAL_USERS`` in the API) setting is disabled by default. External users refer to users authenticated externally with a service like LDAP, or any of the other SSO services. This setting ensures external users cannot *create* their own tokens. If you enable then disable it, any tokens created by external users in the meantime will still exist, and are not automatically revoked."
msgstr "**Allow External Users to Create Oauth2 Tokens**（API 中的 ``ALLOW_OAUTH2_FOR_EXTERNAL_USERS``）设置默认禁用。外部用户是指使用类似 LDAP 的服务或其它 SSO 服务进行外部身份验证的用户。此设置确保外部用户无法*创建*自己的令牌。如果启用了这个设置并在随后禁用它，则外部用户在此期间创建的令牌仍会存在，它们不会被自动撤销。"

#: ../../source/oauth2_token_auth.rst:458
msgid "Alternatively, you can use the ``manage`` utility, :ref:`ag_manage_utility_revoke_tokens`, to revoke tokens as described in the the :ref:`ag_token_utility` section."
msgstr "或者，您可以使用 ``manage`` 实用程序 :ref:`ag_manage_utility_revoke_tokens` 撤销令牌，如 :ref:`ag_token_utility` 部分中所述。"

#: ../../source/oauth2_token_auth.rst:461
msgid "This setting can be configured at the system-level in the |at| User Interface:"
msgstr "此设置可以在 |at| 用户界面中的系统级别进行配置："

#: ../../source/oauth2_token_auth.rst:466
msgid "Upon success, a response of ``200 OK`` displays. Verify the deletion by checking whether the token is present in the ``/api/v2/tokens/`` endpoint."
msgstr "成功后，会显示一个响应 ``200 OK``。通过检查 ``/api/v2/tokens/`` 端点中是否存在令牌来验证删除。"

